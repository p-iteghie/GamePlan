{"ast":null,"code":"'use strict';\n\nmodule.exports = exports = install;\nexports.usage = 'Attempts to install pre-built binary for module';\nconst fs = require('fs');\nconst path = require('path');\nconst log = require('npmlog');\nconst existsAsync = fs.exists || path.exists;\nconst versioning = require('./util/versioning.js');\nconst napi = require('./util/napi.js');\nconst makeDir = require('make-dir');\n// for fetching binaries\nconst fetch = require('node-fetch');\nconst tar = require('tar');\nlet npgVersion = 'unknown';\ntry {\n  // Read own package.json to get the current node-pre-pyp version.\n  const ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\n  npgVersion = JSON.parse(ownPackageJSON).version;\n} catch (e) {\n  // do nothing\n}\nfunction place_binary(uri, targetDir, opts, callback) {\n  log.http('GET', uri);\n\n  // Try getting version info from the currently running npm.\n  const envVersionInfo = process.env.npm_config_user_agent || 'node ' + process.version;\n  const sanitized = uri.replace('+', '%2B');\n  const requestOpts = {\n    uri: sanitized,\n    headers: {\n      'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\n    },\n    follow_max: 10\n  };\n  if (opts.cafile) {\n    try {\n      requestOpts.ca = fs.readFileSync(opts.cafile);\n    } catch (e) {\n      return callback(e);\n    }\n  } else if (opts.ca) {\n    requestOpts.ca = opts.ca;\n  }\n  const proxyUrl = opts.proxy || process.env.http_proxy || process.env.HTTP_PROXY || process.env.npm_config_proxy;\n  let agent;\n  if (proxyUrl) {\n    const ProxyAgent = require('https-proxy-agent');\n    agent = new ProxyAgent(proxyUrl);\n    log.http('download', 'proxy agent configured using: \"%s\"', proxyUrl);\n  }\n  fetch(sanitized, {\n    agent\n  }).then(res => {\n    if (!res.ok) {\n      throw new Error(`response status ${res.status} ${res.statusText} on ${sanitized}`);\n    }\n    const dataStream = res.body;\n    return new Promise((resolve, reject) => {\n      let extractions = 0;\n      const countExtractions = entry => {\n        extractions += 1;\n        log.info('install', 'unpacking %s', entry.path);\n      };\n      dataStream.pipe(extract(targetDir, countExtractions)).on('error', e => {\n        reject(e);\n      });\n      dataStream.on('end', () => {\n        resolve(`extracted file count: ${extractions}`);\n      });\n      dataStream.on('error', e => {\n        reject(e);\n      });\n    });\n  }).then(text => {\n    log.info(text);\n    callback();\n  }).catch(e => {\n    log.error(`install ${e.message}`);\n    callback(e);\n  });\n}\nfunction extract(to, onentry) {\n  return tar.extract({\n    cwd: to,\n    strip: 1,\n    onentry\n  });\n}\nfunction extract_from_local(from, targetDir, callback) {\n  if (!fs.existsSync(from)) {\n    return callback(new Error('Cannot find file ' + from));\n  }\n  log.info('Found local file to extract from ' + from);\n\n  // extract helpers\n  let extractCount = 0;\n  function countExtractions(entry) {\n    extractCount += 1;\n    log.info('install', 'unpacking ' + entry.path);\n  }\n  function afterExtract(err) {\n    if (err) return callback(err);\n    if (extractCount === 0) {\n      return callback(new Error('There was a fatal problem while extracting the tarball'));\n    }\n    log.info('tarball', 'done parsing tarball');\n    callback();\n  }\n  fs.createReadStream(from).pipe(extract(targetDir, countExtractions)).on('close', afterExtract).on('error', afterExtract);\n}\nfunction do_build(gyp, argv, callback) {\n  const args = ['rebuild'].concat(argv);\n  gyp.todo.push({\n    name: 'build',\n    args: args\n  });\n  process.nextTick(callback);\n}\nfunction print_fallback_error(err, opts, package_json) {\n  const fallback_message = ' (falling back to source compile with node-gyp)';\n  let full_message = '';\n  if (err.statusCode !== undefined) {\n    // If we got a network response it but failed to download\n    // it means remote binaries are not available, so let's try to help\n    // the user/developer with the info to debug why\n    full_message = 'Pre-built binaries not found for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn('Tried to download(' + err.statusCode + '): ' + opts.hosted_tarball);\n    log.warn(full_message);\n    log.http(err.message);\n  } else {\n    // If we do not have a statusCode that means an unexpected error\n    // happened and prevented an http response, so we output the exact error\n    full_message = 'Pre-built binaries not installable for ' + package_json.name + '@' + package_json.version;\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\n    full_message += fallback_message;\n    log.warn(full_message);\n    log.warn('Hit error ' + err.message);\n  }\n}\n\n//\n// install\n//\nfunction install(gyp, argv, callback) {\n  const package_json = gyp.package_json;\n  const napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  const source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\n  const update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\n  const should_do_source_build = source_build === package_json.name || source_build === true || source_build === 'true';\n  if (should_do_source_build) {\n    log.info('build', 'requesting source compile');\n    return do_build(gyp, argv, callback);\n  } else {\n    const fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\n    let should_do_fallback_build = fallback_to_build === package_json.name || fallback_to_build === true || fallback_to_build === 'true';\n    // but allow override from npm\n    if (process.env.npm_config_argv) {\n      const cooked = JSON.parse(process.env.npm_config_argv).cooked;\n      const match = cooked.indexOf('--fallback-to-build');\n      if (match > -1 && cooked.length > match && cooked[match + 1] === 'false') {\n        should_do_fallback_build = false;\n        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');\n      }\n    }\n    let opts;\n    try {\n      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n    } catch (err) {\n      return callback(err);\n    }\n    opts.ca = gyp.opts.ca;\n    opts.cafile = gyp.opts.cafile;\n    const from = opts.hosted_tarball;\n    const to = opts.module_path;\n    const binary_module = path.join(to, opts.module_name + '.node');\n    existsAsync(binary_module, found => {\n      if (!update_binary) {\n        if (found) {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" already installed');\n          console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\n          return callback();\n        }\n        log.info('check', 'checked for \"' + binary_module + '\" (not found)');\n      }\n      makeDir(to).then(() => {\n        const fileName = from.startsWith('file://') && from.slice('file://'.length);\n        if (fileName) {\n          extract_from_local(fileName, to, after_place);\n        } else {\n          place_binary(from, to, opts, after_place);\n        }\n      }).catch(err => {\n        after_place(err);\n      });\n      function after_place(err) {\n        if (err && should_do_fallback_build) {\n          print_fallback_error(err, opts, package_json);\n          return do_build(gyp, argv, callback);\n        } else if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" is installed via remote');\n          return callback();\n        }\n      }\n    });\n  }\n}","map":{"version":3,"names":["module","exports","install","usage","fs","require","path","log","existsAsync","exists","versioning","napi","makeDir","fetch","tar","npgVersion","ownPackageJSON","readFileSync","join","__dirname","JSON","parse","version","e","place_binary","uri","targetDir","opts","callback","http","envVersionInfo","process","env","npm_config_user_agent","sanitized","replace","requestOpts","headers","follow_max","cafile","ca","proxyUrl","proxy","http_proxy","HTTP_PROXY","npm_config_proxy","agent","ProxyAgent","then","res","ok","Error","status","statusText","dataStream","body","Promise","resolve","reject","extractions","countExtractions","entry","info","pipe","extract","on","text","catch","error","message","to","onentry","cwd","strip","extract_from_local","from","existsSync","extractCount","afterExtract","err","createReadStream","do_build","gyp","argv","args","concat","todo","push","name","nextTick","print_fallback_error","package_json","fallback_message","full_message","statusCode","undefined","runtime","target","versions","node","node_abi","libc","warn","hosted_tarball","napi_build_version","get_napi_build_version_from_command_args","source_build","build_from_source","update_binary","should_do_source_build","fallback_to_build","should_do_fallback_build","npm_config_argv","cooked","match","indexOf","length","evaluate","module_path","binary_module","module_name","found","console","fileName","startsWith","slice","after_place"],"sources":["C:/Users/Lyss/Documents/CEN3031/GamePlan/node_modules/@mapbox/node-pre-gyp/lib/install.js"],"sourcesContent":["'use strict';\r\n\r\nmodule.exports = exports = install;\r\n\r\nexports.usage = 'Attempts to install pre-built binary for module';\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst log = require('npmlog');\r\nconst existsAsync = fs.exists || path.exists;\r\nconst versioning = require('./util/versioning.js');\r\nconst napi = require('./util/napi.js');\r\nconst makeDir = require('make-dir');\r\n// for fetching binaries\r\nconst fetch = require('node-fetch');\r\nconst tar = require('tar');\r\n\r\nlet npgVersion = 'unknown';\r\ntry {\r\n  // Read own package.json to get the current node-pre-pyp version.\r\n  const ownPackageJSON = fs.readFileSync(path.join(__dirname, '..', 'package.json'), 'utf8');\r\n  npgVersion = JSON.parse(ownPackageJSON).version;\r\n} catch (e) {\r\n  // do nothing\r\n}\r\n\r\nfunction place_binary(uri, targetDir, opts, callback) {\r\n  log.http('GET', uri);\r\n\r\n  // Try getting version info from the currently running npm.\r\n  const envVersionInfo = process.env.npm_config_user_agent ||\r\n        'node ' + process.version;\r\n\r\n  const sanitized = uri.replace('+', '%2B');\r\n  const requestOpts = {\r\n    uri: sanitized,\r\n    headers: {\r\n      'User-Agent': 'node-pre-gyp (v' + npgVersion + ', ' + envVersionInfo + ')'\r\n    },\r\n    follow_max: 10\r\n  };\r\n\r\n  if (opts.cafile) {\r\n    try {\r\n      requestOpts.ca = fs.readFileSync(opts.cafile);\r\n    } catch (e) {\r\n      return callback(e);\r\n    }\r\n  } else if (opts.ca) {\r\n    requestOpts.ca = opts.ca;\r\n  }\r\n\r\n  const proxyUrl = opts.proxy ||\r\n                    process.env.http_proxy ||\r\n                    process.env.HTTP_PROXY ||\r\n                    process.env.npm_config_proxy;\r\n  let agent;\r\n  if (proxyUrl) {\r\n    const ProxyAgent = require('https-proxy-agent');\r\n    agent = new ProxyAgent(proxyUrl);\r\n    log.http('download', 'proxy agent configured using: \"%s\"', proxyUrl);\r\n  }\r\n\r\n  fetch(sanitized, { agent })\r\n    .then((res) => {\r\n      if (!res.ok) {\r\n        throw new Error(`response status ${res.status} ${res.statusText} on ${sanitized}`);\r\n      }\r\n      const dataStream = res.body;\r\n\r\n      return new Promise((resolve, reject) => {\r\n        let extractions = 0;\r\n        const countExtractions = (entry) => {\r\n          extractions += 1;\r\n          log.info('install', 'unpacking %s', entry.path);\r\n        };\r\n\r\n        dataStream.pipe(extract(targetDir, countExtractions))\r\n          .on('error', (e) => {\r\n            reject(e);\r\n          });\r\n        dataStream.on('end', () => {\r\n          resolve(`extracted file count: ${extractions}`);\r\n        });\r\n        dataStream.on('error', (e) => {\r\n          reject(e);\r\n        });\r\n      });\r\n    })\r\n    .then((text) => {\r\n      log.info(text);\r\n      callback();\r\n    })\r\n    .catch((e) => {\r\n      log.error(`install ${e.message}`);\r\n      callback(e);\r\n    });\r\n}\r\n\r\nfunction extract(to, onentry) {\r\n  return tar.extract({\r\n    cwd: to,\r\n    strip: 1,\r\n    onentry\r\n  });\r\n}\r\n\r\nfunction extract_from_local(from, targetDir, callback) {\r\n  if (!fs.existsSync(from)) {\r\n    return callback(new Error('Cannot find file ' + from));\r\n  }\r\n  log.info('Found local file to extract from ' + from);\r\n\r\n  // extract helpers\r\n  let extractCount = 0;\r\n  function countExtractions(entry) {\r\n    extractCount += 1;\r\n    log.info('install', 'unpacking ' + entry.path);\r\n  }\r\n  function afterExtract(err) {\r\n    if (err) return callback(err);\r\n    if (extractCount === 0) {\r\n      return callback(new Error('There was a fatal problem while extracting the tarball'));\r\n    }\r\n    log.info('tarball', 'done parsing tarball');\r\n    callback();\r\n  }\r\n\r\n  fs.createReadStream(from).pipe(extract(targetDir, countExtractions))\r\n    .on('close', afterExtract)\r\n    .on('error', afterExtract);\r\n}\r\n\r\nfunction do_build(gyp, argv, callback) {\r\n  const args = ['rebuild'].concat(argv);\r\n  gyp.todo.push({ name: 'build', args: args });\r\n  process.nextTick(callback);\r\n}\r\n\r\nfunction print_fallback_error(err, opts, package_json) {\r\n  const fallback_message = ' (falling back to source compile with node-gyp)';\r\n  let full_message = '';\r\n  if (err.statusCode !== undefined) {\r\n    // If we got a network response it but failed to download\r\n    // it means remote binaries are not available, so let's try to help\r\n    // the user/developer with the info to debug why\r\n    full_message = 'Pre-built binaries not found for ' + package_json.name + '@' + package_json.version;\r\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\r\n    full_message += fallback_message;\r\n    log.warn('Tried to download(' + err.statusCode + '): ' + opts.hosted_tarball);\r\n    log.warn(full_message);\r\n    log.http(err.message);\r\n  } else {\r\n    // If we do not have a statusCode that means an unexpected error\r\n    // happened and prevented an http response, so we output the exact error\r\n    full_message = 'Pre-built binaries not installable for ' + package_json.name + '@' + package_json.version;\r\n    full_message += ' and ' + opts.runtime + '@' + (opts.target || process.versions.node) + ' (' + opts.node_abi + ' ABI, ' + opts.libc + ')';\r\n    full_message += fallback_message;\r\n    log.warn(full_message);\r\n    log.warn('Hit error ' + err.message);\r\n  }\r\n}\r\n\r\n//\r\n// install\r\n//\r\nfunction install(gyp, argv, callback) {\r\n  const package_json = gyp.package_json;\r\n  const napi_build_version = napi.get_napi_build_version_from_command_args(argv);\r\n  const source_build = gyp.opts['build-from-source'] || gyp.opts.build_from_source;\r\n  const update_binary = gyp.opts['update-binary'] || gyp.opts.update_binary;\r\n  const should_do_source_build = source_build === package_json.name || (source_build === true || source_build === 'true');\r\n  if (should_do_source_build) {\r\n    log.info('build', 'requesting source compile');\r\n    return do_build(gyp, argv, callback);\r\n  } else {\r\n    const fallback_to_build = gyp.opts['fallback-to-build'] || gyp.opts.fallback_to_build;\r\n    let should_do_fallback_build = fallback_to_build === package_json.name || (fallback_to_build === true || fallback_to_build === 'true');\r\n    // but allow override from npm\r\n    if (process.env.npm_config_argv) {\r\n      const cooked = JSON.parse(process.env.npm_config_argv).cooked;\r\n      const match = cooked.indexOf('--fallback-to-build');\r\n      if (match > -1 && cooked.length > match && cooked[match + 1] === 'false') {\r\n        should_do_fallback_build = false;\r\n        log.info('install', 'Build fallback disabled via npm flag: --fallback-to-build=false');\r\n      }\r\n    }\r\n    let opts;\r\n    try {\r\n      opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\r\n    } catch (err) {\r\n      return callback(err);\r\n    }\r\n\r\n    opts.ca = gyp.opts.ca;\r\n    opts.cafile = gyp.opts.cafile;\r\n\r\n    const from = opts.hosted_tarball;\r\n    const to = opts.module_path;\r\n    const binary_module = path.join(to, opts.module_name + '.node');\r\n    existsAsync(binary_module, (found) => {\r\n      if (!update_binary) {\r\n        if (found) {\r\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" already installed');\r\n          console.log('Pass --update-binary to reinstall or --build-from-source to recompile');\r\n          return callback();\r\n        }\r\n        log.info('check', 'checked for \"' + binary_module + '\" (not found)');\r\n      }\r\n\r\n      makeDir(to).then(() => {\r\n        const fileName = from.startsWith('file://') && from.slice('file://'.length);\r\n        if (fileName) {\r\n          extract_from_local(fileName, to, after_place);\r\n        } else {\r\n          place_binary(from, to, opts, after_place);\r\n        }\r\n      }).catch((err) => {\r\n        after_place(err);\r\n      });\r\n\r\n      function after_place(err) {\r\n        if (err && should_do_fallback_build) {\r\n          print_fallback_error(err, opts, package_json);\r\n          return do_build(gyp, argv, callback);\r\n        } else if (err) {\r\n          return callback(err);\r\n        } else {\r\n          console.log('[' + package_json.name + '] Success: \"' + binary_module + '\" is installed via remote');\r\n          return callback();\r\n        }\r\n      }\r\n    });\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}