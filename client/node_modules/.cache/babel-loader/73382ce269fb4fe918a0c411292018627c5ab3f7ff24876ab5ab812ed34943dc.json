{"ast":null,"code":"// unix absolute paths are also absolute on win32, so we use this for both\nconst {\n  isAbsolute,\n  parse\n} = require('path').win32;\n\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nmodule.exports = path => {\n  let r = '';\n  let parsed = parse(path);\n  while (isAbsolute(path) || parsed.root) {\n    // windows will think that //x/y/z has a \"root\" of //x/y/\n    // but strip the //?/C:/ off of //?/C:/path\n    const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ? '/' : parsed.root;\n    path = path.slice(root.length);\n    r += root;\n    parsed = parse(path);\n  }\n  return [r, path];\n};","map":{"version":3,"names":["isAbsolute","parse","require","win32","module","exports","path","r","parsed","root","charAt","slice","length"],"sources":["C:/Users/Lyss/Documents/CEN3031/GamePlan/node_modules/tar/lib/strip-absolute-path.js"],"sourcesContent":["// unix absolute paths are also absolute on win32, so we use this for both\r\nconst { isAbsolute, parse } = require('path').win32\r\n\r\n// returns [root, stripped]\r\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\r\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\r\n// explicitly if it's the first character.\r\n// drive-specific relative paths on Windows get their root stripped off even\r\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\r\nmodule.exports = path => {\r\n  let r = ''\r\n\r\n  let parsed = parse(path)\r\n  while (isAbsolute(path) || parsed.root) {\r\n    // windows will think that //x/y/z has a \"root\" of //x/y/\r\n    // but strip the //?/C:/ off of //?/C:/path\r\n    const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ? '/'\r\n      : parsed.root\r\n    path = path.slice(root.length)\r\n    r += root\r\n    parsed = parse(path)\r\n  }\r\n  return [r, path]\r\n}\r\n"],"mappings":"AAAA;AACA,MAAM;EAAEA,UAAU;EAAEC;AAAM,CAAC,GAAGC,OAAO,CAAC,MAAM,CAAC,CAACC,KAAK;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAGC,IAAI,IAAI;EACvB,IAAIC,CAAC,GAAG,EAAE;EAEV,IAAIC,MAAM,GAAGP,KAAK,CAACK,IAAI,CAAC;EACxB,OAAON,UAAU,CAACM,IAAI,CAAC,IAAIE,MAAM,CAACC,IAAI,EAAE;IACtC;IACA;IACA,MAAMA,IAAI,GAAGH,IAAI,CAACI,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIJ,IAAI,CAACK,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,MAAM,GAAG,GAAG,GACpEH,MAAM,CAACC,IAAI;IACfH,IAAI,GAAGA,IAAI,CAACK,KAAK,CAACF,IAAI,CAACG,MAAM,CAAC;IAC9BL,CAAC,IAAIE,IAAI;IACTD,MAAM,GAAGP,KAAK,CAACK,IAAI,CAAC;EACtB;EACA,OAAO,CAACC,CAAC,EAAED,IAAI,CAAC;AAClB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}