{"ast":null,"code":"'use strict';\n\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null\n};\nconst EE = require('events');\nconst Stream = require('stream');\nconst SD = require('string_decoder').StringDecoder;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\nconst DESTROYED = Symbol('destroyed');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst defer = fn => Promise.resolve().then(fn);\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nconst ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented');\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBuffer = b => b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src;\n    this.dest = dest;\n    this.opts = opts;\n    this.ondrain = () => src[RESUME]();\n    dest.on('drain', this.ondrain);\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain);\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors() {}\n  end() {\n    this.unpipe();\n    if (this.opts.end) this.dest.end();\n  }\n}\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors);\n    super.unpipe();\n  }\n  constructor(src, dest, opts) {\n    super(src, dest, opts);\n    this.proxyErrors = er => dest.emit('error', er);\n    src.on('error', this.proxyErrors);\n  }\n}\nmodule.exports = class Minipass extends Stream {\n  constructor(options) {\n    super();\n    this[FLOWING] = false;\n    // whether we're explicitly paused\n    this[PAUSED] = false;\n    this.pipes = [];\n    this.buffer = [];\n    this[OBJECTMODE] = options && options.objectMode || false;\n    if (this[OBJECTMODE]) this[ENCODING] = null;else this[ENCODING] = options && options.encoding || null;\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null;\n    this[ASYNC] = options && !!options.async || false;\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;\n    this[EOF] = false;\n    this[EMITTED_END] = false;\n    this[EMITTING_END] = false;\n    this[CLOSED] = false;\n    this[EMITTED_ERROR] = null;\n    this.writable = true;\n    this.readable = true;\n    this[BUFFERLENGTH] = 0;\n    this[DESTROYED] = false;\n  }\n  get bufferLength() {\n    return this[BUFFERLENGTH];\n  }\n  get encoding() {\n    return this[ENCODING];\n  }\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n    if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null;\n      if (this.buffer.length) this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk));\n    }\n    this[ENCODING] = enc;\n  }\n  setEncoding(enc) {\n    this.encoding = enc;\n  }\n  get objectMode() {\n    return this[OBJECTMODE];\n  }\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om;\n  }\n  get ['async']() {\n    return this[ASYNC];\n  }\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a;\n  }\n  write(chunk, encoding, cb) {\n    if (this[EOF]) throw new Error('write after end');\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {\n        code: 'ERR_STREAM_DESTROYED'\n      }));\n      return true;\n    }\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (!encoding) encoding = 'utf8';\n    const fn = this[ASYNC] ? defer : f => f();\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true;\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n      if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this.flowing;\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this.flowing;\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' &&\n    // unless it is a string already ready for us to use\n    !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding);\n    }\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n    if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n    if (cb) fn(cb);\n    return this.flowing;\n  }\n  read(n) {\n    if (this[DESTROYED]) return null;\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]();\n      return null;\n    }\n    if (this[OBJECTMODE]) n = null;\n    if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this.buffer = [this.buffer.join('')];else this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];\n    }\n    const ret = this[READ](n || null, this.buffer[0]);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n      this.buffer[0] = chunk.slice(n);\n      chunk = chunk.slice(0, n);\n      this[BUFFERLENGTH] -= n;\n    }\n    this.emit('data', chunk);\n    if (!this.buffer.length && !this[EOF]) this.emit('drain');\n    return chunk;\n  }\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    this[EOF] = true;\n    this.writable = false;\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();\n    return this;\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return;\n    this[PAUSED] = false;\n    this[FLOWING] = true;\n    this.emit('resume');\n    if (this.buffer.length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n  }\n  resume() {\n    return this[RESUME]();\n  }\n  pause() {\n    this[FLOWING] = false;\n    this[PAUSED] = true;\n  }\n  get destroyed() {\n    return this[DESTROYED];\n  }\n  get flowing() {\n    return this[FLOWING];\n  }\n  get paused() {\n    return this[PAUSED];\n  }\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n    this.buffer.push(chunk);\n  }\n  [BUFFERSHIFT]() {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this.buffer[0].length;\n    }\n    return this.buffer.shift();\n  }\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));\n    if (!noDrain && !this.buffer.length && !this[EOF]) this.emit('drain');\n  }\n  [FLUSHCHUNK](chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false;\n  }\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return;\n    const ended = this[EMITTED_END];\n    opts = opts || {};\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false;else opts.end = opts.end !== false;\n    opts.proxyErrors = !!opts.proxyErrors;\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end();\n    } else {\n      this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));\n      if (this[ASYNC]) defer(() => this[RESUME]());else this[RESUME]();\n    }\n    return dest;\n  }\n  unpipe(dest) {\n    const p = this.pipes.find(p => p.dest === dest);\n    if (p) {\n      this.pipes.splice(this.pipes.indexOf(p), 1);\n      p.unpipe();\n    }\n  }\n  addListener(ev, fn) {\n    return this.on(ev, fn);\n  }\n  on(ev, fn) {\n    const ret = super.on(ev, fn);\n    if (ev === 'data' && !this.pipes.length && !this.flowing) this[RESUME]();else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) super.emit('readable');else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev);\n      this.removeAllListeners(ev);\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));else fn.call(this, this[EMITTED_ERROR]);\n    }\n    return ret;\n  }\n  get emittedEnd() {\n    return this[EMITTED_END];\n  }\n  [MAYBE_EMIT_END]() {\n    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {\n      this[EMITTING_END] = true;\n      this.emit('end');\n      this.emit('prefinish');\n      this.emit('finish');\n      if (this[CLOSED]) this.emit('close');\n      this[EMITTING_END] = false;\n    }\n  }\n  emit(ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;else if (ev === 'data') {\n      return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);\n    } else if (ev === 'end') {\n      return this[EMITEND]();\n    } else if (ev === 'close') {\n      this[CLOSED] = true;\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return;\n      const ret = super.emit('close');\n      this.removeAllListeners('close');\n      return ret;\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data;\n      const ret = super.emit('error', data);\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume');\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev);\n      this.removeAllListeners(ev);\n      return ret;\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n  [EMITDATA](data) {\n    for (const p of this.pipes) {\n      if (p.dest.write(data) === false) this.pause();\n    }\n    const ret = super.emit('data', data);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n  [EMITEND]() {\n    if (this[EMITTED_END]) return;\n    this[EMITTED_END] = true;\n    this.readable = false;\n    if (this[ASYNC]) defer(() => this[EMITEND2]());else this[EMITEND2]();\n  }\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end();\n      if (data) {\n        for (const p of this.pipes) {\n          p.dest.write(data);\n        }\n        super.emit('data', data);\n      }\n    }\n    for (const p of this.pipes) {\n      p.end();\n    }\n    const ret = super.emit('end');\n    this.removeAllListeners('end');\n    return ret;\n  }\n\n  // const all = await stream.collect()\n  collect() {\n    const buf = [];\n    if (!this[OBJECTMODE]) buf.dataLength = 0;\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise();\n    this.on('data', c => {\n      buf.push(c);\n      if (!this[OBJECTMODE]) buf.dataLength += c.length;\n    });\n    return p.then(() => buf);\n  }\n\n  // const data = await stream.concat()\n  concat() {\n    return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then(buf => this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength));\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n      this.on('error', er => reject(er));\n      this.on('end', () => resolve());\n    });\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR]() {\n    const next = () => {\n      const res = this.read();\n      if (res !== null) return Promise.resolve({\n        done: false,\n        value: res\n      });\n      if (this[EOF]) return Promise.resolve({\n        done: true\n      });\n      let resolve = null;\n      let reject = null;\n      const onerr = er => {\n        this.removeListener('data', ondata);\n        this.removeListener('end', onend);\n        reject(er);\n      };\n      const ondata = value => {\n        this.removeListener('error', onerr);\n        this.removeListener('end', onend);\n        this.pause();\n        resolve({\n          value: value,\n          done: !!this[EOF]\n        });\n      };\n      const onend = () => {\n        this.removeListener('error', onerr);\n        this.removeListener('data', ondata);\n        resolve({\n          done: true\n        });\n      };\n      const ondestroy = () => onerr(new Error('stream destroyed'));\n      return new Promise((res, rej) => {\n        reject = rej;\n        resolve = res;\n        this.once(DESTROYED, ondestroy);\n        this.once('error', onerr);\n        this.once('end', onend);\n        this.once('data', ondata);\n      });\n    };\n    return {\n      next\n    };\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR]() {\n    const next = () => {\n      const value = this.read();\n      const done = value === null;\n      return {\n        value,\n        done\n      };\n    };\n    return {\n      next\n    };\n  }\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er);else this.emit(DESTROYED);\n      return this;\n    }\n    this[DESTROYED] = true;\n\n    // throw away all buffered data, it's never coming out\n    this.buffer.length = 0;\n    this[BUFFERLENGTH] = 0;\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close();\n    if (er) this.emit('error', er);else\n      // if no error to emit, still reject pending promises\n      this.emit(DESTROYED);\n    return this;\n  }\n  static isStream(s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === 'function' ||\n    // readable\n    typeof s.write === 'function' && typeof s.end === 'function' // writable\n    ));\n  }\n};","map":{"version":3,"names":["proc","process","stdout","stderr","EE","require","Stream","SD","StringDecoder","EOF","Symbol","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","EMITTED_ERROR","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","EMITDATA","EMITEND","EMITEND2","ASYNC","defer","fn","Promise","resolve","then","doIter","global","_MP_NO_ITERATOR_SYMBOLS_","ASYNCITERATOR","asyncIterator","ITERATOR","iterator","isEndish","ev","isArrayBuffer","b","ArrayBuffer","constructor","name","byteLength","isArrayBufferView","Buffer","isBuffer","isView","Pipe","src","dest","opts","ondrain","on","unpipe","removeListener","proxyErrors","end","PipeProxyErrors","er","emit","module","exports","Minipass","options","pipes","buffer","objectMode","encoding","async","writable","readable","bufferLength","enc","Error","lastNeed","length","map","chunk","write","setEncoding","om","a","cb","Object","assign","code","f","from","byteOffset","flowing","read","n","join","concat","ret","slice","once","resume","pause","destroyed","paused","push","shift","noDrain","pipe","ended","p","find","splice","indexOf","addListener","removeAllListeners","call","emittedEnd","data","extra","collect","buf","dataLength","promise","c","reject","next","res","done","value","onerr","ondata","onend","ondestroy","rej","destroy","close","isStream","s"],"sources":["C:/Users/piteg/source/repos/p-iteghie/GamePlan/node_modules/minizlib/node_modules/minipass/index.js"],"sourcesContent":["'use strict'\r\nconst proc = typeof process === 'object' && process ? process : {\r\n  stdout: null,\r\n  stderr: null,\r\n}\r\nconst EE = require('events')\r\nconst Stream = require('stream')\r\nconst SD = require('string_decoder').StringDecoder\r\n\r\nconst EOF = Symbol('EOF')\r\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\r\nconst EMITTED_END = Symbol('emittedEnd')\r\nconst EMITTING_END = Symbol('emittingEnd')\r\nconst EMITTED_ERROR = Symbol('emittedError')\r\nconst CLOSED = Symbol('closed')\r\nconst READ = Symbol('read')\r\nconst FLUSH = Symbol('flush')\r\nconst FLUSHCHUNK = Symbol('flushChunk')\r\nconst ENCODING = Symbol('encoding')\r\nconst DECODER = Symbol('decoder')\r\nconst FLOWING = Symbol('flowing')\r\nconst PAUSED = Symbol('paused')\r\nconst RESUME = Symbol('resume')\r\nconst BUFFERLENGTH = Symbol('bufferLength')\r\nconst BUFFERPUSH = Symbol('bufferPush')\r\nconst BUFFERSHIFT = Symbol('bufferShift')\r\nconst OBJECTMODE = Symbol('objectMode')\r\nconst DESTROYED = Symbol('destroyed')\r\nconst EMITDATA = Symbol('emitData')\r\nconst EMITEND = Symbol('emitEnd')\r\nconst EMITEND2 = Symbol('emitEnd2')\r\nconst ASYNC = Symbol('async')\r\n\r\nconst defer = fn => Promise.resolve().then(fn)\r\n\r\n// TODO remove when Node v8 support drops\r\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\r\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\r\n  || Symbol('asyncIterator not implemented')\r\nconst ITERATOR = doIter && Symbol.iterator\r\n  || Symbol('iterator not implemented')\r\n\r\n// events that mean 'the stream is over'\r\n// these are treated specially, and re-emitted\r\n// if they are listened for after emitting.\r\nconst isEndish = ev =>\r\n  ev === 'end' ||\r\n  ev === 'finish' ||\r\n  ev === 'prefinish'\r\n\r\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\r\n  typeof b === 'object' &&\r\n  b.constructor &&\r\n  b.constructor.name === 'ArrayBuffer' &&\r\n  b.byteLength >= 0\r\n\r\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\r\n\r\nclass Pipe {\r\n  constructor (src, dest, opts) {\r\n    this.src = src\r\n    this.dest = dest\r\n    this.opts = opts\r\n    this.ondrain = () => src[RESUME]()\r\n    dest.on('drain', this.ondrain)\r\n  }\r\n  unpipe () {\r\n    this.dest.removeListener('drain', this.ondrain)\r\n  }\r\n  // istanbul ignore next - only here for the prototype\r\n  proxyErrors () {}\r\n  end () {\r\n    this.unpipe()\r\n    if (this.opts.end)\r\n      this.dest.end()\r\n  }\r\n}\r\n\r\nclass PipeProxyErrors extends Pipe {\r\n  unpipe () {\r\n    this.src.removeListener('error', this.proxyErrors)\r\n    super.unpipe()\r\n  }\r\n  constructor (src, dest, opts) {\r\n    super(src, dest, opts)\r\n    this.proxyErrors = er => dest.emit('error', er)\r\n    src.on('error', this.proxyErrors)\r\n  }\r\n}\r\n\r\nmodule.exports = class Minipass extends Stream {\r\n  constructor (options) {\r\n    super()\r\n    this[FLOWING] = false\r\n    // whether we're explicitly paused\r\n    this[PAUSED] = false\r\n    this.pipes = []\r\n    this.buffer = []\r\n    this[OBJECTMODE] = options && options.objectMode || false\r\n    if (this[OBJECTMODE])\r\n      this[ENCODING] = null\r\n    else\r\n      this[ENCODING] = options && options.encoding || null\r\n    if (this[ENCODING] === 'buffer')\r\n      this[ENCODING] = null\r\n    this[ASYNC] = options && !!options.async || false\r\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\r\n    this[EOF] = false\r\n    this[EMITTED_END] = false\r\n    this[EMITTING_END] = false\r\n    this[CLOSED] = false\r\n    this[EMITTED_ERROR] = null\r\n    this.writable = true\r\n    this.readable = true\r\n    this[BUFFERLENGTH] = 0\r\n    this[DESTROYED] = false\r\n  }\r\n\r\n  get bufferLength () { return this[BUFFERLENGTH] }\r\n\r\n  get encoding () { return this[ENCODING] }\r\n  set encoding (enc) {\r\n    if (this[OBJECTMODE])\r\n      throw new Error('cannot set encoding in objectMode')\r\n\r\n    if (this[ENCODING] && enc !== this[ENCODING] &&\r\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\r\n      throw new Error('cannot change encoding')\r\n\r\n    if (this[ENCODING] !== enc) {\r\n      this[DECODER] = enc ? new SD(enc) : null\r\n      if (this.buffer.length)\r\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\r\n    }\r\n\r\n    this[ENCODING] = enc\r\n  }\r\n\r\n  setEncoding (enc) {\r\n    this.encoding = enc\r\n  }\r\n\r\n  get objectMode () { return this[OBJECTMODE] }\r\n  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }\r\n\r\n  get ['async'] () { return this[ASYNC] }\r\n  set ['async'] (a) { this[ASYNC] = this[ASYNC] || !!a }\r\n\r\n  write (chunk, encoding, cb) {\r\n    if (this[EOF])\r\n      throw new Error('write after end')\r\n\r\n    if (this[DESTROYED]) {\r\n      this.emit('error', Object.assign(\r\n        new Error('Cannot call write after a stream was destroyed'),\r\n        { code: 'ERR_STREAM_DESTROYED' }\r\n      ))\r\n      return true\r\n    }\r\n\r\n    if (typeof encoding === 'function')\r\n      cb = encoding, encoding = 'utf8'\r\n\r\n    if (!encoding)\r\n      encoding = 'utf8'\r\n\r\n    const fn = this[ASYNC] ? defer : f => f()\r\n\r\n    // convert array buffers and typed array views into buffers\r\n    // at some point in the future, we may want to do the opposite!\r\n    // leave strings and buffers as-is\r\n    // anything else switches us into object mode\r\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\r\n      if (isArrayBufferView(chunk))\r\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\r\n      else if (isArrayBuffer(chunk))\r\n        chunk = Buffer.from(chunk)\r\n      else if (typeof chunk !== 'string')\r\n        // use the setter so we throw if we have encoding set\r\n        this.objectMode = true\r\n    }\r\n\r\n    // handle object mode up front, since it's simpler\r\n    // this yields better performance, fewer checks later.\r\n    if (this[OBJECTMODE]) {\r\n      /* istanbul ignore if - maybe impossible? */\r\n      if (this.flowing && this[BUFFERLENGTH] !== 0)\r\n        this[FLUSH](true)\r\n\r\n      if (this.flowing)\r\n        this.emit('data', chunk)\r\n      else\r\n        this[BUFFERPUSH](chunk)\r\n\r\n      if (this[BUFFERLENGTH] !== 0)\r\n        this.emit('readable')\r\n\r\n      if (cb)\r\n        fn(cb)\r\n\r\n      return this.flowing\r\n    }\r\n\r\n    // at this point the chunk is a buffer or string\r\n    // don't buffer it up or send it to the decoder\r\n    if (!chunk.length) {\r\n      if (this[BUFFERLENGTH] !== 0)\r\n        this.emit('readable')\r\n      if (cb)\r\n        fn(cb)\r\n      return this.flowing\r\n    }\r\n\r\n    // fast-path writing strings of same encoding to a stream with\r\n    // an empty buffer, skipping the buffer/decoder dance\r\n    if (typeof chunk === 'string' &&\r\n        // unless it is a string already ready for us to use\r\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\r\n      chunk = Buffer.from(chunk, encoding)\r\n    }\r\n\r\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\r\n      chunk = this[DECODER].write(chunk)\r\n\r\n    // Note: flushing CAN potentially switch us into not-flowing mode\r\n    if (this.flowing && this[BUFFERLENGTH] !== 0)\r\n      this[FLUSH](true)\r\n\r\n    if (this.flowing)\r\n      this.emit('data', chunk)\r\n    else\r\n      this[BUFFERPUSH](chunk)\r\n\r\n    if (this[BUFFERLENGTH] !== 0)\r\n      this.emit('readable')\r\n\r\n    if (cb)\r\n      fn(cb)\r\n\r\n    return this.flowing\r\n  }\r\n\r\n  read (n) {\r\n    if (this[DESTROYED])\r\n      return null\r\n\r\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\r\n      this[MAYBE_EMIT_END]()\r\n      return null\r\n    }\r\n\r\n    if (this[OBJECTMODE])\r\n      n = null\r\n\r\n    if (this.buffer.length > 1 && !this[OBJECTMODE]) {\r\n      if (this.encoding)\r\n        this.buffer = [this.buffer.join('')]\r\n      else\r\n        this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])]\r\n    }\r\n\r\n    const ret = this[READ](n || null, this.buffer[0])\r\n    this[MAYBE_EMIT_END]()\r\n    return ret\r\n  }\r\n\r\n  [READ] (n, chunk) {\r\n    if (n === chunk.length || n === null)\r\n      this[BUFFERSHIFT]()\r\n    else {\r\n      this.buffer[0] = chunk.slice(n)\r\n      chunk = chunk.slice(0, n)\r\n      this[BUFFERLENGTH] -= n\r\n    }\r\n\r\n    this.emit('data', chunk)\r\n\r\n    if (!this.buffer.length && !this[EOF])\r\n      this.emit('drain')\r\n\r\n    return chunk\r\n  }\r\n\r\n  end (chunk, encoding, cb) {\r\n    if (typeof chunk === 'function')\r\n      cb = chunk, chunk = null\r\n    if (typeof encoding === 'function')\r\n      cb = encoding, encoding = 'utf8'\r\n    if (chunk)\r\n      this.write(chunk, encoding)\r\n    if (cb)\r\n      this.once('end', cb)\r\n    this[EOF] = true\r\n    this.writable = false\r\n\r\n    // if we haven't written anything, then go ahead and emit,\r\n    // even if we're not reading.\r\n    // we'll re-emit if a new 'end' listener is added anyway.\r\n    // This makes MP more suitable to write-only use cases.\r\n    if (this.flowing || !this[PAUSED])\r\n      this[MAYBE_EMIT_END]()\r\n    return this\r\n  }\r\n\r\n  // don't let the internal resume be overwritten\r\n  [RESUME] () {\r\n    if (this[DESTROYED])\r\n      return\r\n\r\n    this[PAUSED] = false\r\n    this[FLOWING] = true\r\n    this.emit('resume')\r\n    if (this.buffer.length)\r\n      this[FLUSH]()\r\n    else if (this[EOF])\r\n      this[MAYBE_EMIT_END]()\r\n    else\r\n      this.emit('drain')\r\n  }\r\n\r\n  resume () {\r\n    return this[RESUME]()\r\n  }\r\n\r\n  pause () {\r\n    this[FLOWING] = false\r\n    this[PAUSED] = true\r\n  }\r\n\r\n  get destroyed () {\r\n    return this[DESTROYED]\r\n  }\r\n\r\n  get flowing () {\r\n    return this[FLOWING]\r\n  }\r\n\r\n  get paused () {\r\n    return this[PAUSED]\r\n  }\r\n\r\n  [BUFFERPUSH] (chunk) {\r\n    if (this[OBJECTMODE])\r\n      this[BUFFERLENGTH] += 1\r\n    else\r\n      this[BUFFERLENGTH] += chunk.length\r\n    this.buffer.push(chunk)\r\n  }\r\n\r\n  [BUFFERSHIFT] () {\r\n    if (this.buffer.length) {\r\n      if (this[OBJECTMODE])\r\n        this[BUFFERLENGTH] -= 1\r\n      else\r\n        this[BUFFERLENGTH] -= this.buffer[0].length\r\n    }\r\n    return this.buffer.shift()\r\n  }\r\n\r\n  [FLUSH] (noDrain) {\r\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\r\n\r\n    if (!noDrain && !this.buffer.length && !this[EOF])\r\n      this.emit('drain')\r\n  }\r\n\r\n  [FLUSHCHUNK] (chunk) {\r\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\r\n  }\r\n\r\n  pipe (dest, opts) {\r\n    if (this[DESTROYED])\r\n      return\r\n\r\n    const ended = this[EMITTED_END]\r\n    opts = opts || {}\r\n    if (dest === proc.stdout || dest === proc.stderr)\r\n      opts.end = false\r\n    else\r\n      opts.end = opts.end !== false\r\n    opts.proxyErrors = !!opts.proxyErrors\r\n\r\n    // piping an ended stream ends immediately\r\n    if (ended) {\r\n      if (opts.end)\r\n        dest.end()\r\n    } else {\r\n      this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts)\r\n        : new PipeProxyErrors(this, dest, opts))\r\n      if (this[ASYNC])\r\n        defer(() => this[RESUME]())\r\n      else\r\n        this[RESUME]()\r\n    }\r\n\r\n    return dest\r\n  }\r\n\r\n  unpipe (dest) {\r\n    const p = this.pipes.find(p => p.dest === dest)\r\n    if (p) {\r\n      this.pipes.splice(this.pipes.indexOf(p), 1)\r\n      p.unpipe()\r\n    }\r\n  }\r\n\r\n  addListener (ev, fn) {\r\n    return this.on(ev, fn)\r\n  }\r\n\r\n  on (ev, fn) {\r\n    const ret = super.on(ev, fn)\r\n    if (ev === 'data' && !this.pipes.length && !this.flowing)\r\n      this[RESUME]()\r\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\r\n      super.emit('readable')\r\n    else if (isEndish(ev) && this[EMITTED_END]) {\r\n      super.emit(ev)\r\n      this.removeAllListeners(ev)\r\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\r\n      if (this[ASYNC])\r\n        defer(() => fn.call(this, this[EMITTED_ERROR]))\r\n      else\r\n        fn.call(this, this[EMITTED_ERROR])\r\n    }\r\n    return ret\r\n  }\r\n\r\n  get emittedEnd () {\r\n    return this[EMITTED_END]\r\n  }\r\n\r\n  [MAYBE_EMIT_END] () {\r\n    if (!this[EMITTING_END] &&\r\n        !this[EMITTED_END] &&\r\n        !this[DESTROYED] &&\r\n        this.buffer.length === 0 &&\r\n        this[EOF]) {\r\n      this[EMITTING_END] = true\r\n      this.emit('end')\r\n      this.emit('prefinish')\r\n      this.emit('finish')\r\n      if (this[CLOSED])\r\n        this.emit('close')\r\n      this[EMITTING_END] = false\r\n    }\r\n  }\r\n\r\n  emit (ev, data, ...extra) {\r\n    // error and close are only events allowed after calling destroy()\r\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\r\n      return\r\n    else if (ev === 'data') {\r\n      return !data ? false\r\n        : this[ASYNC] ? defer(() => this[EMITDATA](data))\r\n        : this[EMITDATA](data)\r\n    } else if (ev === 'end') {\r\n      return this[EMITEND]()\r\n    } else if (ev === 'close') {\r\n      this[CLOSED] = true\r\n      // don't emit close before 'end' and 'finish'\r\n      if (!this[EMITTED_END] && !this[DESTROYED])\r\n        return\r\n      const ret = super.emit('close')\r\n      this.removeAllListeners('close')\r\n      return ret\r\n    } else if (ev === 'error') {\r\n      this[EMITTED_ERROR] = data\r\n      const ret = super.emit('error', data)\r\n      this[MAYBE_EMIT_END]()\r\n      return ret\r\n    } else if (ev === 'resume') {\r\n      const ret = super.emit('resume')\r\n      this[MAYBE_EMIT_END]()\r\n      return ret\r\n    } else if (ev === 'finish' || ev === 'prefinish') {\r\n      const ret = super.emit(ev)\r\n      this.removeAllListeners(ev)\r\n      return ret\r\n    }\r\n\r\n    // Some other unknown event\r\n    const ret = super.emit(ev, data, ...extra)\r\n    this[MAYBE_EMIT_END]()\r\n    return ret\r\n  }\r\n\r\n  [EMITDATA] (data) {\r\n    for (const p of this.pipes) {\r\n      if (p.dest.write(data) === false)\r\n        this.pause()\r\n    }\r\n    const ret = super.emit('data', data)\r\n    this[MAYBE_EMIT_END]()\r\n    return ret\r\n  }\r\n\r\n  [EMITEND] () {\r\n    if (this[EMITTED_END])\r\n      return\r\n\r\n    this[EMITTED_END] = true\r\n    this.readable = false\r\n    if (this[ASYNC])\r\n      defer(() => this[EMITEND2]())\r\n    else\r\n      this[EMITEND2]()\r\n  }\r\n\r\n  [EMITEND2] () {\r\n    if (this[DECODER]) {\r\n      const data = this[DECODER].end()\r\n      if (data) {\r\n        for (const p of this.pipes) {\r\n          p.dest.write(data)\r\n        }\r\n        super.emit('data', data)\r\n      }\r\n    }\r\n\r\n    for (const p of this.pipes) {\r\n      p.end()\r\n    }\r\n    const ret = super.emit('end')\r\n    this.removeAllListeners('end')\r\n    return ret\r\n  }\r\n\r\n  // const all = await stream.collect()\r\n  collect () {\r\n    const buf = []\r\n    if (!this[OBJECTMODE])\r\n      buf.dataLength = 0\r\n    // set the promise first, in case an error is raised\r\n    // by triggering the flow here.\r\n    const p = this.promise()\r\n    this.on('data', c => {\r\n      buf.push(c)\r\n      if (!this[OBJECTMODE])\r\n        buf.dataLength += c.length\r\n    })\r\n    return p.then(() => buf)\r\n  }\r\n\r\n  // const data = await stream.concat()\r\n  concat () {\r\n    return this[OBJECTMODE]\r\n      ? Promise.reject(new Error('cannot concat in objectMode'))\r\n      : this.collect().then(buf =>\r\n          this[OBJECTMODE]\r\n            ? Promise.reject(new Error('cannot concat in objectMode'))\r\n            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))\r\n  }\r\n\r\n  // stream.promise().then(() => done, er => emitted error)\r\n  promise () {\r\n    return new Promise((resolve, reject) => {\r\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\r\n      this.on('error', er => reject(er))\r\n      this.on('end', () => resolve())\r\n    })\r\n  }\r\n\r\n  // for await (let chunk of stream)\r\n  [ASYNCITERATOR] () {\r\n    const next = () => {\r\n      const res = this.read()\r\n      if (res !== null)\r\n        return Promise.resolve({ done: false, value: res })\r\n\r\n      if (this[EOF])\r\n        return Promise.resolve({ done: true })\r\n\r\n      let resolve = null\r\n      let reject = null\r\n      const onerr = er => {\r\n        this.removeListener('data', ondata)\r\n        this.removeListener('end', onend)\r\n        reject(er)\r\n      }\r\n      const ondata = value => {\r\n        this.removeListener('error', onerr)\r\n        this.removeListener('end', onend)\r\n        this.pause()\r\n        resolve({ value: value, done: !!this[EOF] })\r\n      }\r\n      const onend = () => {\r\n        this.removeListener('error', onerr)\r\n        this.removeListener('data', ondata)\r\n        resolve({ done: true })\r\n      }\r\n      const ondestroy = () => onerr(new Error('stream destroyed'))\r\n      return new Promise((res, rej) => {\r\n        reject = rej\r\n        resolve = res\r\n        this.once(DESTROYED, ondestroy)\r\n        this.once('error', onerr)\r\n        this.once('end', onend)\r\n        this.once('data', ondata)\r\n      })\r\n    }\r\n\r\n    return { next }\r\n  }\r\n\r\n  // for (let chunk of stream)\r\n  [ITERATOR] () {\r\n    const next = () => {\r\n      const value = this.read()\r\n      const done = value === null\r\n      return { value, done }\r\n    }\r\n    return { next }\r\n  }\r\n\r\n  destroy (er) {\r\n    if (this[DESTROYED]) {\r\n      if (er)\r\n        this.emit('error', er)\r\n      else\r\n        this.emit(DESTROYED)\r\n      return this\r\n    }\r\n\r\n    this[DESTROYED] = true\r\n\r\n    // throw away all buffered data, it's never coming out\r\n    this.buffer.length = 0\r\n    this[BUFFERLENGTH] = 0\r\n\r\n    if (typeof this.close === 'function' && !this[CLOSED])\r\n      this.close()\r\n\r\n    if (er)\r\n      this.emit('error', er)\r\n    else // if no error to emit, still reject pending promises\r\n      this.emit(DESTROYED)\r\n\r\n    return this\r\n  }\r\n\r\n  static isStream (s) {\r\n    return !!s && (s instanceof Minipass || s instanceof Stream ||\r\n      s instanceof EE && (\r\n        typeof s.pipe === 'function' || // readable\r\n        (typeof s.write === 'function' && typeof s.end === 'function') // writable\r\n      ))\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}