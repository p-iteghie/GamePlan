{"ast":null,"code":"'use strict';\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\nconst assert = require('assert');\nconst Parser = require('./parse.js');\nconst fs = require('fs');\nconst fsm = require('fs-minipass');\nconst path = require('path');\nconst mkdir = require('./mkdir.js');\nconst wc = require('./winchars.js');\nconst pathReservations = require('./path-reservations.js');\nconst stripAbsolutePath = require('./strip-absolute-path.js');\nconst normPath = require('./normalize-windows-path.js');\nconst stripSlash = require('./strip-trailing-slashes.js');\nconst normalize = require('./normalize-unicode.js');\nconst ONENTRY = Symbol('onEntry');\nconst CHECKFS = Symbol('checkFs');\nconst CHECKFS2 = Symbol('checkFs2');\nconst PRUNECACHE = Symbol('pruneCache');\nconst ISREUSABLE = Symbol('isReusable');\nconst MAKEFS = Symbol('makeFs');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst LINK = Symbol('link');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst UNSUPPORTED = Symbol('unsupported');\nconst CHECKPATH = Symbol('checkPath');\nconst MKDIR = Symbol('mkdir');\nconst ONERROR = Symbol('onError');\nconst PENDING = Symbol('pending');\nconst PEND = Symbol('pend');\nconst UNPEND = Symbol('unpend');\nconst ENDED = Symbol('ended');\nconst MAYBECLOSE = Symbol('maybeClose');\nconst SKIP = Symbol('skip');\nconst DOCHOWN = Symbol('doChown');\nconst UID = Symbol('uid');\nconst GID = Symbol('gid');\nconst CHECKED_CWD = Symbol('checkedCwd');\nconst crypto = require('crypto');\nconst getFlag = require('./get-write-flag.js');\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst isWindows = platform === 'win32';\nconst DEFAULT_MAX_DEPTH = 1024;\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (!isWindows) {\n    return fs.unlink(path, cb);\n  }\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.rename(path, name, er => {\n    if (er) {\n      return cb(er);\n    }\n    fs.unlink(name, cb);\n  });\n};\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (!isWindows) {\n    return fs.unlinkSync(path);\n  }\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.renameSync(path, name);\n  fs.unlinkSync(name);\n};\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = path => stripSlash(normPath(normalize(path))).toLowerCase();\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs);\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path);\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n      cache.delete(path);\n    }\n  }\n};\nconst dropCache = cache => {\n  for (const key of cache.keys()) {\n    cache.delete(key);\n  }\n};\nclass Unpack extends Parser {\n  constructor(opt) {\n    if (!opt) {\n      opt = {};\n    }\n    opt.ondone = _ => {\n      this[ENDED] = true;\n      this[MAYBECLOSE]();\n    };\n    super(opt);\n    this[CHECKED_CWD] = false;\n    this.reservations = pathReservations();\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null;\n    this.writable = true;\n    this.readable = false;\n    this[PENDING] = 0;\n    this[ENDED] = false;\n    this.dirCache = opt.dirCache || new Map();\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {\n        throw new TypeError('cannot set owner without number uid and gid');\n      }\n      if (opt.preserveOwner) {\n        throw new TypeError('cannot preserve owner in archive and also set owner explicitly');\n      }\n      this.uid = opt.uid;\n      this.gid = opt.gid;\n      this.setOwner = true;\n    } else {\n      this.uid = null;\n      this.gid = null;\n      this.setOwner = false;\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {\n      this.preserveOwner = process.getuid && process.getuid() === 0;\n    } else {\n      this.preserveOwner = !!opt.preserveOwner;\n    }\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;\n\n    // prevent excessively deep nesting of subfolders\n    // set to `Infinity` to remove this restriction\n    this.maxDepth = typeof opt.maxDepth === 'number' ? opt.maxDepth : DEFAULT_MAX_DEPTH;\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true;\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || isWindows;\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer;\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep;\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime;\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths;\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink;\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()));\n    this.strip = +opt.strip || 0;\n    // if we're not chmodding, then we don't need the process umask\n    this.processUmask = opt.noChmod ? 0 : process.umask();\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask;\n\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || 0o0777 & ~this.umask;\n    this.fmode = opt.fmode || 0o0666 & ~this.umask;\n    this.on('entry', entry => this[ONENTRY](entry));\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  warn(code, msg, data = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n      data.recoverable = false;\n    }\n    return super.warn(code, msg, data);\n  }\n  [MAYBECLOSE]() {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish');\n      this.emit('finish');\n      this.emit('end');\n    }\n  }\n  [CHECKPATH](entry) {\n    const p = normPath(entry.path);\n    const parts = p.split('/');\n    if (this.strip) {\n      if (parts.length < this.strip) {\n        return false;\n      }\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/');\n        if (linkparts.length >= this.strip) {\n          entry.linkpath = linkparts.slice(this.strip).join('/');\n        } else {\n          return false;\n        }\n      }\n      parts.splice(0, this.strip);\n      entry.path = parts.join('/');\n    }\n    if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {\n      this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {\n        entry,\n        path: p,\n        depth: parts.length,\n        maxDepth: this.maxDepth\n      });\n      return false;\n    }\n    if (!this.preservePaths) {\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p\n        });\n        return false;\n      }\n\n      // strip off the root\n      const [root, stripped] = stripAbsolutePath(p);\n      if (root) {\n        entry.path = stripped;\n        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n          entry,\n          path: p\n        });\n      }\n    }\n    if (path.isAbsolute(entry.path)) {\n      entry.absolute = normPath(path.resolve(entry.path));\n    } else {\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path));\n    }\n\n    // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n    /* istanbul ignore if - defense in depth */\n    if (!this.preservePaths && entry.absolute.indexOf(this.cwd + '/') !== 0 && entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd\n      });\n      return false;\n    }\n\n    // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n    if (entry.absolute === this.cwd && entry.type !== 'Directory' && entry.type !== 'GNUDumpDir') {\n      return false;\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const {\n        root: aRoot\n      } = path.win32.parse(entry.absolute);\n      entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));\n      const {\n        root: pRoot\n      } = path.win32.parse(entry.path);\n      entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));\n    }\n    return true;\n  }\n  [ONENTRY](entry) {\n    if (!this[CHECKPATH](entry)) {\n      return entry.resume();\n    }\n    assert.equal(typeof entry.absolute, 'string');\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode) {\n          entry.mode = entry.mode | 0o700;\n        }\n\n      // eslint-disable-next-line no-fallthrough\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry);\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n      default:\n        return this[UNSUPPORTED](entry);\n    }\n  }\n  [ONERROR](er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError') {\n      this.emit('error', er);\n    } else {\n      this.warn('TAR_ENTRY_ERROR', er, {\n        entry\n      });\n      this[UNPEND]();\n      entry.resume();\n    }\n  }\n  [MKDIR](dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode,\n      noChmod: this.noChmod\n    }, cb);\n  }\n  [DOCHOWN](entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown || this.preserveOwner && (typeof entry.uid === 'number' && entry.uid !== this.processUid || typeof entry.gid === 'number' && entry.gid !== this.processGid) || typeof this.uid === 'number' && this.uid !== this.processUid || typeof this.gid === 'number' && this.gid !== this.processGid;\n  }\n  [UID](entry) {\n    return uint32(this.uid, entry.uid, this.processUid);\n  }\n  [GID](entry) {\n    return uint32(this.gid, entry.gid, this.processGid);\n  }\n  [FILE](entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode;\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false\n    });\n    stream.on('error', er => {\n      if (stream.fd) {\n        fs.close(stream.fd, () => {});\n      }\n\n      // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n      stream.write = () => true;\n      this[ONERROR](er, entry);\n      fullyDone();\n    });\n    let actions = 1;\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd) {\n          fs.close(stream.fd, () => {});\n        }\n        this[ONERROR](er, entry);\n        fullyDone();\n        return;\n      }\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          if (er) {\n            this[ONERROR](er, entry);\n          } else {\n            this[UNPEND]();\n          }\n          fullyDone();\n        });\n      }\n    };\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute;\n      const fd = stream.fd;\n      if (entry.mtime && !this.noMtime) {\n        actions++;\n        const atime = entry.atime || new Date();\n        const mtime = entry.mtime;\n        fs.futimes(fd, atime, mtime, er => er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er)) : done());\n      }\n      if (this[DOCHOWN](entry)) {\n        actions++;\n        const uid = this[UID](entry);\n        const gid = this[GID](entry);\n        fs.fchown(fd, uid, gid, er => er ? fs.chown(abs, uid, gid, er2 => done(er2 && er)) : done());\n      }\n      done();\n    });\n    const tx = this.transform ? this.transform(entry) || entry : entry;\n    if (tx !== entry) {\n      tx.on('error', er => {\n        this[ONERROR](er, entry);\n        fullyDone();\n      });\n      entry.pipe(tx);\n    }\n    tx.pipe(stream);\n  }\n  [DIRECTORY](entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode;\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        this[ONERROR](er, entry);\n        fullyDone();\n        return;\n      }\n      let actions = 1;\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone();\n          this[UNPEND]();\n          entry.resume();\n        }\n      };\n      if (entry.mtime && !this.noMtime) {\n        actions++;\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);\n      }\n      if (this[DOCHOWN](entry)) {\n        actions++;\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done);\n      }\n      done();\n    });\n  }\n  [UNSUPPORTED](entry) {\n    entry.unsupported = true;\n    this.warn('TAR_ENTRY_UNSUPPORTED', `unsupported entry type: ${entry.type}`, {\n      entry\n    });\n    entry.resume();\n  }\n  [SYMLINK](entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done);\n  }\n  [HARDLINK](entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath));\n    this[LINK](entry, linkpath, 'link', done);\n  }\n  [PEND]() {\n    this[PENDING]++;\n  }\n  [UNPEND]() {\n    this[PENDING]--;\n    this[MAYBECLOSE]();\n  }\n  [SKIP](entry) {\n    this[UNPEND]();\n    entry.resume();\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE](entry, st) {\n    return entry.type === 'File' && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS](entry) {\n    this[PEND]();\n    const paths = [entry.path];\n    if (entry.linkpath) {\n      paths.push(entry.linkpath);\n    }\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done));\n  }\n  [PRUNECACHE](entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink') {\n      dropCache(this.dirCache);\n    } else if (entry.type !== 'Directory') {\n      pruneCache(this.dirCache, entry.absolute);\n    }\n  }\n  [CHECKFS2](entry, fullyDone) {\n    this[PRUNECACHE](entry);\n    const done = er => {\n      this[PRUNECACHE](entry);\n      fullyDone(er);\n    };\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry);\n          done();\n          return;\n        }\n        this[CHECKED_CWD] = true;\n        start();\n      });\n    };\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute));\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry);\n              done();\n              return;\n            }\n            afterMakeParent();\n          });\n        }\n      }\n      afterMakeParent();\n    };\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry);\n          done();\n          return;\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n          return this[MAKEFS](null, entry, done);\n        }\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod && entry.mode && (st.mode & 0o7777) !== entry.mode;\n            const afterChmod = er => this[MAKEFS](er, entry, done);\n            if (!needChmod) {\n              return afterChmod();\n            }\n            return fs.chmod(entry.absolute, entry.mode, afterChmod);\n          }\n          // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er => this[MAKEFS](er, entry, done));\n          }\n        }\n\n        // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n        if (entry.absolute === this.cwd) {\n          return this[MAKEFS](null, entry, done);\n        }\n        unlinkFile(entry.absolute, er => this[MAKEFS](er, entry, done));\n      });\n    };\n    if (this[CHECKED_CWD]) {\n      start();\n    } else {\n      checkCwd();\n    }\n  }\n  [MAKEFS](er, entry, done) {\n    if (er) {\n      this[ONERROR](er, entry);\n      done();\n      return;\n    }\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done);\n      case 'Link':\n        return this[HARDLINK](entry, done);\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done);\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done);\n    }\n  }\n  [LINK](entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er) {\n        this[ONERROR](er, entry);\n      } else {\n        this[UNPEND]();\n        entry.resume();\n      }\n      done();\n    });\n  }\n}\nconst callSync = fn => {\n  try {\n    return [null, fn()];\n  } catch (er) {\n    return [er, null];\n  }\n};\nclass UnpackSync extends Unpack {\n  [MAKEFS](er, entry) {\n    return super[MAKEFS](er, entry, () => {});\n  }\n  [CHECKFS](entry) {\n    this[PRUNECACHE](entry);\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode);\n      if (er) {\n        return this[ONERROR](er, entry);\n      }\n      this[CHECKED_CWD] = true;\n    }\n\n    // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute));\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode);\n        if (mkParent) {\n          return this[ONERROR](mkParent, entry);\n        }\n      }\n    }\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute));\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n      return this[SKIP](entry);\n    }\n    if (lstatEr || this[ISREUSABLE](entry, st)) {\n      return this[MAKEFS](null, entry);\n    }\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod && entry.mode && (st.mode & 0o7777) !== entry.mode;\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode);\n        }) : [];\n        return this[MAKEFS](er, entry);\n      }\n      // not a dir entry, have to remove it\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute));\n      this[MAKEFS](er, entry);\n    }\n\n    // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n    const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));\n    this[MAKEFS](er, entry);\n  }\n  [FILE](entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode;\n    const oner = er => {\n      let closeError;\n      try {\n        fs.closeSync(fd);\n      } catch (e) {\n        closeError = e;\n      }\n      if (er || closeError) {\n        this[ONERROR](er || closeError, entry);\n      }\n      done();\n    };\n    let fd;\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode);\n    } catch (er) {\n      return oner(er);\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry;\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry));\n      entry.pipe(tx);\n    }\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length);\n      } catch (er) {\n        oner(er);\n      }\n    });\n    tx.on('end', _ => {\n      let er = null;\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date();\n        const mtime = entry.mtime;\n        try {\n          fs.futimesSync(fd, atime, mtime);\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime);\n          } catch (utimeser) {\n            er = futimeser;\n          }\n        }\n      }\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry);\n        const gid = this[GID](entry);\n        try {\n          fs.fchownSync(fd, uid, gid);\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid);\n          } catch (chowner) {\n            er = er || fchowner;\n          }\n        }\n      }\n      oner(er);\n    });\n  }\n  [DIRECTORY](entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode;\n    const er = this[MKDIR](entry.absolute, mode);\n    if (er) {\n      this[ONERROR](er, entry);\n      done();\n      return;\n    }\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));\n      } catch (er) {}\n    }\n    done();\n    entry.resume();\n  }\n  [MKDIR](dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode\n      });\n    } catch (er) {\n      return er;\n    }\n  }\n  [LINK](entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute);\n      done();\n      entry.resume();\n    } catch (er) {\n      return this[ONERROR](er, entry);\n    }\n  }\n}\nUnpack.Sync = UnpackSync;\nmodule.exports = Unpack;","map":{"version":3,"names":["assert","require","Parser","fs","fsm","path","mkdir","wc","pathReservations","stripAbsolutePath","normPath","stripSlash","normalize","ONENTRY","Symbol","CHECKFS","CHECKFS2","PRUNECACHE","ISREUSABLE","MAKEFS","FILE","DIRECTORY","LINK","SYMLINK","HARDLINK","UNSUPPORTED","CHECKPATH","MKDIR","ONERROR","PENDING","PEND","UNPEND","ENDED","MAYBECLOSE","SKIP","DOCHOWN","UID","GID","CHECKED_CWD","crypto","getFlag","platform","process","env","TESTING_TAR_FAKE_PLATFORM","isWindows","DEFAULT_MAX_DEPTH","unlinkFile","cb","unlink","name","randomBytes","toString","rename","er","unlinkFileSync","unlinkSync","renameSync","uint32","a","b","c","cacheKeyNormalize","toLowerCase","pruneCache","cache","abs","keys","pnorm","indexOf","delete","dropCache","key","Unpack","constructor","opt","ondone","_","reservations","transform","writable","readable","dirCache","Map","uid","gid","TypeError","preserveOwner","setOwner","undefined","getuid","processUid","processGid","getgid","maxDepth","forceChown","win32","newer","keep","noMtime","preservePaths","cwd","resolve","strip","processUmask","noChmod","umask","dmode","fmode","on","entry","warn","code","msg","data","recoverable","emit","p","parts","split","length","type","linkparts","linkpath","slice","join","splice","isFinite","depth","includes","test","root","stripped","isAbsolute","absolute","resolvedPath","aRoot","parse","encode","pRoot","resume","equal","mode","dir","preserve","fullyDone","stream","WriteStream","flags","size","autoClose","fd","close","write","actions","done","mtime","atime","Date","futimes","utimes","er2","fchown","chown","tx","pipe","unsupported","st","isFile","nlink","paths","push","reserve","checkCwd","start","parent","dirname","afterMakeParent","lstat","lstatEr","isDirectory","needChmod","afterChmod","chmod","rmdir","link","callSync","fn","UnpackSync","mkParent","lstatSync","chmodSync","rmdirSync","oner","closeError","closeSync","e","openSync","chunk","writeSync","futimesSync","futimeser","utimesSync","utimeser","fchownSync","fchowner","chownSync","chowner","sync","Sync","module","exports"],"sources":["C:/Users/piteg/source/repos/p-iteghie/GamePlan/node_modules/tar/lib/unpack.js"],"sourcesContent":["'use strict'\r\n\r\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\r\n// but the path reservations are required to avoid race conditions where\r\n// parallelized unpack ops may mess with one another, due to dependencies\r\n// (like a Link depending on its target) or destructive operations (like\r\n// clobbering an fs object to create one of a different type.)\r\n\r\nconst assert = require('assert')\r\nconst Parser = require('./parse.js')\r\nconst fs = require('fs')\r\nconst fsm = require('fs-minipass')\r\nconst path = require('path')\r\nconst mkdir = require('./mkdir.js')\r\nconst wc = require('./winchars.js')\r\nconst pathReservations = require('./path-reservations.js')\r\nconst stripAbsolutePath = require('./strip-absolute-path.js')\r\nconst normPath = require('./normalize-windows-path.js')\r\nconst stripSlash = require('./strip-trailing-slashes.js')\r\nconst normalize = require('./normalize-unicode.js')\r\n\r\nconst ONENTRY = Symbol('onEntry')\r\nconst CHECKFS = Symbol('checkFs')\r\nconst CHECKFS2 = Symbol('checkFs2')\r\nconst PRUNECACHE = Symbol('pruneCache')\r\nconst ISREUSABLE = Symbol('isReusable')\r\nconst MAKEFS = Symbol('makeFs')\r\nconst FILE = Symbol('file')\r\nconst DIRECTORY = Symbol('directory')\r\nconst LINK = Symbol('link')\r\nconst SYMLINK = Symbol('symlink')\r\nconst HARDLINK = Symbol('hardlink')\r\nconst UNSUPPORTED = Symbol('unsupported')\r\nconst CHECKPATH = Symbol('checkPath')\r\nconst MKDIR = Symbol('mkdir')\r\nconst ONERROR = Symbol('onError')\r\nconst PENDING = Symbol('pending')\r\nconst PEND = Symbol('pend')\r\nconst UNPEND = Symbol('unpend')\r\nconst ENDED = Symbol('ended')\r\nconst MAYBECLOSE = Symbol('maybeClose')\r\nconst SKIP = Symbol('skip')\r\nconst DOCHOWN = Symbol('doChown')\r\nconst UID = Symbol('uid')\r\nconst GID = Symbol('gid')\r\nconst CHECKED_CWD = Symbol('checkedCwd')\r\nconst crypto = require('crypto')\r\nconst getFlag = require('./get-write-flag.js')\r\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\r\nconst isWindows = platform === 'win32'\r\nconst DEFAULT_MAX_DEPTH = 1024\r\n\r\n// Unlinks on Windows are not atomic.\r\n//\r\n// This means that if you have a file entry, followed by another\r\n// file entry with an identical name, and you cannot re-use the file\r\n// (because it's a hardlink, or because unlink:true is set, or it's\r\n// Windows, which does not have useful nlink values), then the unlink\r\n// will be committed to the disk AFTER the new file has been written\r\n// over the old one, deleting the new file.\r\n//\r\n// To work around this, on Windows systems, we rename the file and then\r\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\r\n// know of a better way to do this, given windows' non-atomic unlink\r\n// semantics.\r\n//\r\n// See: https://github.com/npm/node-tar/issues/183\r\n/* istanbul ignore next */\r\nconst unlinkFile = (path, cb) => {\r\n  if (!isWindows) {\r\n    return fs.unlink(path, cb)\r\n  }\r\n\r\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\r\n  fs.rename(path, name, er => {\r\n    if (er) {\r\n      return cb(er)\r\n    }\r\n    fs.unlink(name, cb)\r\n  })\r\n}\r\n\r\n/* istanbul ignore next */\r\nconst unlinkFileSync = path => {\r\n  if (!isWindows) {\r\n    return fs.unlinkSync(path)\r\n  }\r\n\r\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\r\n  fs.renameSync(path, name)\r\n  fs.unlinkSync(name)\r\n}\r\n\r\n// this.gid, entry.gid, this.processUid\r\nconst uint32 = (a, b, c) =>\r\n  a === a >>> 0 ? a\r\n  : b === b >>> 0 ? b\r\n  : c\r\n\r\n// clear the cache if it's a case-insensitive unicode-squashing match.\r\n// we can't know if the current file system is case-sensitive or supports\r\n// unicode fully, so we check for similarity on the maximally compatible\r\n// representation.  Err on the side of pruning, since all it's doing is\r\n// preventing lstats, and it's not the end of the world if we get a false\r\n// positive.\r\n// Note that on windows, we always drop the entire cache whenever a\r\n// symbolic link is encountered, because 8.3 filenames are impossible\r\n// to reason about, and collisions are hazards rather than just failures.\r\nconst cacheKeyNormalize = path => stripSlash(normPath(normalize(path)))\r\n  .toLowerCase()\r\n\r\nconst pruneCache = (cache, abs) => {\r\n  abs = cacheKeyNormalize(abs)\r\n  for (const path of cache.keys()) {\r\n    const pnorm = cacheKeyNormalize(path)\r\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\r\n      cache.delete(path)\r\n    }\r\n  }\r\n}\r\n\r\nconst dropCache = cache => {\r\n  for (const key of cache.keys()) {\r\n    cache.delete(key)\r\n  }\r\n}\r\n\r\nclass Unpack extends Parser {\r\n  constructor (opt) {\r\n    if (!opt) {\r\n      opt = {}\r\n    }\r\n\r\n    opt.ondone = _ => {\r\n      this[ENDED] = true\r\n      this[MAYBECLOSE]()\r\n    }\r\n\r\n    super(opt)\r\n\r\n    this[CHECKED_CWD] = false\r\n\r\n    this.reservations = pathReservations()\r\n\r\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\r\n\r\n    this.writable = true\r\n    this.readable = false\r\n\r\n    this[PENDING] = 0\r\n    this[ENDED] = false\r\n\r\n    this.dirCache = opt.dirCache || new Map()\r\n\r\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\r\n      // need both or neither\r\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {\r\n        throw new TypeError('cannot set owner without number uid and gid')\r\n      }\r\n      if (opt.preserveOwner) {\r\n        throw new TypeError(\r\n          'cannot preserve owner in archive and also set owner explicitly')\r\n      }\r\n      this.uid = opt.uid\r\n      this.gid = opt.gid\r\n      this.setOwner = true\r\n    } else {\r\n      this.uid = null\r\n      this.gid = null\r\n      this.setOwner = false\r\n    }\r\n\r\n    // default true for root\r\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {\r\n      this.preserveOwner = process.getuid && process.getuid() === 0\r\n    } else {\r\n      this.preserveOwner = !!opt.preserveOwner\r\n    }\r\n\r\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\r\n      process.getuid() : null\r\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\r\n      process.getgid() : null\r\n\r\n    // prevent excessively deep nesting of subfolders\r\n    // set to `Infinity` to remove this restriction\r\n    this.maxDepth = typeof opt.maxDepth === 'number'\r\n      ? opt.maxDepth\r\n      : DEFAULT_MAX_DEPTH\r\n\r\n    // mostly just for testing, but useful in some cases.\r\n    // Forcibly trigger a chown on every entry, no matter what\r\n    this.forceChown = opt.forceChown === true\r\n\r\n    // turn ><?| in filenames into 0xf000-higher encoded forms\r\n    this.win32 = !!opt.win32 || isWindows\r\n\r\n    // do not unpack over files that are newer than what's in the archive\r\n    this.newer = !!opt.newer\r\n\r\n    // do not unpack over ANY files\r\n    this.keep = !!opt.keep\r\n\r\n    // do not set mtime/atime of extracted entries\r\n    this.noMtime = !!opt.noMtime\r\n\r\n    // allow .., absolute path entries, and unpacking through symlinks\r\n    // without this, warn and skip .., relativize absolutes, and error\r\n    // on symlinks in extraction path\r\n    this.preservePaths = !!opt.preservePaths\r\n\r\n    // unlink files and links before writing. This breaks existing hard\r\n    // links, and removes symlink directories rather than erroring\r\n    this.unlink = !!opt.unlink\r\n\r\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))\r\n    this.strip = +opt.strip || 0\r\n    // if we're not chmodding, then we don't need the process umask\r\n    this.processUmask = opt.noChmod ? 0 : process.umask()\r\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\r\n\r\n    // default mode for dirs created as parents\r\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\r\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\r\n\r\n    this.on('entry', entry => this[ONENTRY](entry))\r\n  }\r\n\r\n  // a bad or damaged archive is a warning for Parser, but an error\r\n  // when extracting.  Mark those errors as unrecoverable, because\r\n  // the Unpack contract cannot be met.\r\n  warn (code, msg, data = {}) {\r\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\r\n      data.recoverable = false\r\n    }\r\n    return super.warn(code, msg, data)\r\n  }\r\n\r\n  [MAYBECLOSE] () {\r\n    if (this[ENDED] && this[PENDING] === 0) {\r\n      this.emit('prefinish')\r\n      this.emit('finish')\r\n      this.emit('end')\r\n    }\r\n  }\r\n\r\n  [CHECKPATH] (entry) {\r\n    const p = normPath(entry.path)\r\n    const parts = p.split('/')\r\n\r\n    if (this.strip) {\r\n      if (parts.length < this.strip) {\r\n        return false\r\n      }\r\n      if (entry.type === 'Link') {\r\n        const linkparts = normPath(entry.linkpath).split('/')\r\n        if (linkparts.length >= this.strip) {\r\n          entry.linkpath = linkparts.slice(this.strip).join('/')\r\n        } else {\r\n          return false\r\n        }\r\n      }\r\n      parts.splice(0, this.strip)\r\n      entry.path = parts.join('/')\r\n    }\r\n\r\n    if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {\r\n      this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {\r\n        entry,\r\n        path: p,\r\n        depth: parts.length,\r\n        maxDepth: this.maxDepth,\r\n      })\r\n      return false\r\n    }\r\n\r\n    if (!this.preservePaths) {\r\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\r\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\r\n          entry,\r\n          path: p,\r\n        })\r\n        return false\r\n      }\r\n\r\n      // strip off the root\r\n      const [root, stripped] = stripAbsolutePath(p)\r\n      if (root) {\r\n        entry.path = stripped\r\n        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\r\n          entry,\r\n          path: p,\r\n        })\r\n      }\r\n    }\r\n\r\n    if (path.isAbsolute(entry.path)) {\r\n      entry.absolute = normPath(path.resolve(entry.path))\r\n    } else {\r\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path))\r\n    }\r\n\r\n    // if we somehow ended up with a path that escapes the cwd, and we are\r\n    // not in preservePaths mode, then something is fishy!  This should have\r\n    // been prevented above, so ignore this for coverage.\r\n    /* istanbul ignore if - defense in depth */\r\n    if (!this.preservePaths &&\r\n        entry.absolute.indexOf(this.cwd + '/') !== 0 &&\r\n        entry.absolute !== this.cwd) {\r\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\r\n        entry,\r\n        path: normPath(entry.path),\r\n        resolvedPath: entry.absolute,\r\n        cwd: this.cwd,\r\n      })\r\n      return false\r\n    }\r\n\r\n    // an archive can set properties on the extraction directory, but it\r\n    // may not replace the cwd with a different kind of thing entirely.\r\n    if (entry.absolute === this.cwd &&\r\n        entry.type !== 'Directory' &&\r\n        entry.type !== 'GNUDumpDir') {\r\n      return false\r\n    }\r\n\r\n    // only encode : chars that aren't drive letter indicators\r\n    if (this.win32) {\r\n      const { root: aRoot } = path.win32.parse(entry.absolute)\r\n      entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length))\r\n      const { root: pRoot } = path.win32.parse(entry.path)\r\n      entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length))\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  [ONENTRY] (entry) {\r\n    if (!this[CHECKPATH](entry)) {\r\n      return entry.resume()\r\n    }\r\n\r\n    assert.equal(typeof entry.absolute, 'string')\r\n\r\n    switch (entry.type) {\r\n      case 'Directory':\r\n      case 'GNUDumpDir':\r\n        if (entry.mode) {\r\n          entry.mode = entry.mode | 0o700\r\n        }\r\n\r\n      // eslint-disable-next-line no-fallthrough\r\n      case 'File':\r\n      case 'OldFile':\r\n      case 'ContiguousFile':\r\n      case 'Link':\r\n      case 'SymbolicLink':\r\n        return this[CHECKFS](entry)\r\n\r\n      case 'CharacterDevice':\r\n      case 'BlockDevice':\r\n      case 'FIFO':\r\n      default:\r\n        return this[UNSUPPORTED](entry)\r\n    }\r\n  }\r\n\r\n  [ONERROR] (er, entry) {\r\n    // Cwd has to exist, or else nothing works. That's serious.\r\n    // Other errors are warnings, which raise the error in strict\r\n    // mode, but otherwise continue on.\r\n    if (er.name === 'CwdError') {\r\n      this.emit('error', er)\r\n    } else {\r\n      this.warn('TAR_ENTRY_ERROR', er, { entry })\r\n      this[UNPEND]()\r\n      entry.resume()\r\n    }\r\n  }\r\n\r\n  [MKDIR] (dir, mode, cb) {\r\n    mkdir(normPath(dir), {\r\n      uid: this.uid,\r\n      gid: this.gid,\r\n      processUid: this.processUid,\r\n      processGid: this.processGid,\r\n      umask: this.processUmask,\r\n      preserve: this.preservePaths,\r\n      unlink: this.unlink,\r\n      cache: this.dirCache,\r\n      cwd: this.cwd,\r\n      mode: mode,\r\n      noChmod: this.noChmod,\r\n    }, cb)\r\n  }\r\n\r\n  [DOCHOWN] (entry) {\r\n    // in preserve owner mode, chown if the entry doesn't match process\r\n    // in set owner mode, chown if setting doesn't match process\r\n    return this.forceChown ||\r\n      this.preserveOwner &&\r\n      (typeof entry.uid === 'number' && entry.uid !== this.processUid ||\r\n        typeof entry.gid === 'number' && entry.gid !== this.processGid)\r\n      ||\r\n      (typeof this.uid === 'number' && this.uid !== this.processUid ||\r\n        typeof this.gid === 'number' && this.gid !== this.processGid)\r\n  }\r\n\r\n  [UID] (entry) {\r\n    return uint32(this.uid, entry.uid, this.processUid)\r\n  }\r\n\r\n  [GID] (entry) {\r\n    return uint32(this.gid, entry.gid, this.processGid)\r\n  }\r\n\r\n  [FILE] (entry, fullyDone) {\r\n    const mode = entry.mode & 0o7777 || this.fmode\r\n    const stream = new fsm.WriteStream(entry.absolute, {\r\n      flags: getFlag(entry.size),\r\n      mode: mode,\r\n      autoClose: false,\r\n    })\r\n    stream.on('error', er => {\r\n      if (stream.fd) {\r\n        fs.close(stream.fd, () => {})\r\n      }\r\n\r\n      // flush all the data out so that we aren't left hanging\r\n      // if the error wasn't actually fatal.  otherwise the parse\r\n      // is blocked, and we never proceed.\r\n      stream.write = () => true\r\n      this[ONERROR](er, entry)\r\n      fullyDone()\r\n    })\r\n\r\n    let actions = 1\r\n    const done = er => {\r\n      if (er) {\r\n        /* istanbul ignore else - we should always have a fd by now */\r\n        if (stream.fd) {\r\n          fs.close(stream.fd, () => {})\r\n        }\r\n\r\n        this[ONERROR](er, entry)\r\n        fullyDone()\r\n        return\r\n      }\r\n\r\n      if (--actions === 0) {\r\n        fs.close(stream.fd, er => {\r\n          if (er) {\r\n            this[ONERROR](er, entry)\r\n          } else {\r\n            this[UNPEND]()\r\n          }\r\n          fullyDone()\r\n        })\r\n      }\r\n    }\r\n\r\n    stream.on('finish', _ => {\r\n      // if futimes fails, try utimes\r\n      // if utimes fails, fail with the original error\r\n      // same for fchown/chown\r\n      const abs = entry.absolute\r\n      const fd = stream.fd\r\n\r\n      if (entry.mtime && !this.noMtime) {\r\n        actions++\r\n        const atime = entry.atime || new Date()\r\n        const mtime = entry.mtime\r\n        fs.futimes(fd, atime, mtime, er =>\r\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\r\n          : done())\r\n      }\r\n\r\n      if (this[DOCHOWN](entry)) {\r\n        actions++\r\n        const uid = this[UID](entry)\r\n        const gid = this[GID](entry)\r\n        fs.fchown(fd, uid, gid, er =>\r\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\r\n          : done())\r\n      }\r\n\r\n      done()\r\n    })\r\n\r\n    const tx = this.transform ? this.transform(entry) || entry : entry\r\n    if (tx !== entry) {\r\n      tx.on('error', er => {\r\n        this[ONERROR](er, entry)\r\n        fullyDone()\r\n      })\r\n      entry.pipe(tx)\r\n    }\r\n    tx.pipe(stream)\r\n  }\r\n\r\n  [DIRECTORY] (entry, fullyDone) {\r\n    const mode = entry.mode & 0o7777 || this.dmode\r\n    this[MKDIR](entry.absolute, mode, er => {\r\n      if (er) {\r\n        this[ONERROR](er, entry)\r\n        fullyDone()\r\n        return\r\n      }\r\n\r\n      let actions = 1\r\n      const done = _ => {\r\n        if (--actions === 0) {\r\n          fullyDone()\r\n          this[UNPEND]()\r\n          entry.resume()\r\n        }\r\n      }\r\n\r\n      if (entry.mtime && !this.noMtime) {\r\n        actions++\r\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\r\n      }\r\n\r\n      if (this[DOCHOWN](entry)) {\r\n        actions++\r\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\r\n      }\r\n\r\n      done()\r\n    })\r\n  }\r\n\r\n  [UNSUPPORTED] (entry) {\r\n    entry.unsupported = true\r\n    this.warn('TAR_ENTRY_UNSUPPORTED',\r\n      `unsupported entry type: ${entry.type}`, { entry })\r\n    entry.resume()\r\n  }\r\n\r\n  [SYMLINK] (entry, done) {\r\n    this[LINK](entry, entry.linkpath, 'symlink', done)\r\n  }\r\n\r\n  [HARDLINK] (entry, done) {\r\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))\r\n    this[LINK](entry, linkpath, 'link', done)\r\n  }\r\n\r\n  [PEND] () {\r\n    this[PENDING]++\r\n  }\r\n\r\n  [UNPEND] () {\r\n    this[PENDING]--\r\n    this[MAYBECLOSE]()\r\n  }\r\n\r\n  [SKIP] (entry) {\r\n    this[UNPEND]()\r\n    entry.resume()\r\n  }\r\n\r\n  // Check if we can reuse an existing filesystem entry safely and\r\n  // overwrite it, rather than unlinking and recreating\r\n  // Windows doesn't report a useful nlink, so we just never reuse entries\r\n  [ISREUSABLE] (entry, st) {\r\n    return entry.type === 'File' &&\r\n      !this.unlink &&\r\n      st.isFile() &&\r\n      st.nlink <= 1 &&\r\n      !isWindows\r\n  }\r\n\r\n  // check if a thing is there, and if so, try to clobber it\r\n  [CHECKFS] (entry) {\r\n    this[PEND]()\r\n    const paths = [entry.path]\r\n    if (entry.linkpath) {\r\n      paths.push(entry.linkpath)\r\n    }\r\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\r\n  }\r\n\r\n  [PRUNECACHE] (entry) {\r\n    // if we are not creating a directory, and the path is in the dirCache,\r\n    // then that means we are about to delete the directory we created\r\n    // previously, and it is no longer going to be a directory, and neither\r\n    // is any of its children.\r\n    // If a symbolic link is encountered, all bets are off.  There is no\r\n    // reasonable way to sanitize the cache in such a way we will be able to\r\n    // avoid having filesystem collisions.  If this happens with a non-symlink\r\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\r\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\r\n    // to arbitrary writes to anywhere on the system.\r\n    if (entry.type === 'SymbolicLink') {\r\n      dropCache(this.dirCache)\r\n    } else if (entry.type !== 'Directory') {\r\n      pruneCache(this.dirCache, entry.absolute)\r\n    }\r\n  }\r\n\r\n  [CHECKFS2] (entry, fullyDone) {\r\n    this[PRUNECACHE](entry)\r\n\r\n    const done = er => {\r\n      this[PRUNECACHE](entry)\r\n      fullyDone(er)\r\n    }\r\n\r\n    const checkCwd = () => {\r\n      this[MKDIR](this.cwd, this.dmode, er => {\r\n        if (er) {\r\n          this[ONERROR](er, entry)\r\n          done()\r\n          return\r\n        }\r\n        this[CHECKED_CWD] = true\r\n        start()\r\n      })\r\n    }\r\n\r\n    const start = () => {\r\n      if (entry.absolute !== this.cwd) {\r\n        const parent = normPath(path.dirname(entry.absolute))\r\n        if (parent !== this.cwd) {\r\n          return this[MKDIR](parent, this.dmode, er => {\r\n            if (er) {\r\n              this[ONERROR](er, entry)\r\n              done()\r\n              return\r\n            }\r\n            afterMakeParent()\r\n          })\r\n        }\r\n      }\r\n      afterMakeParent()\r\n    }\r\n\r\n    const afterMakeParent = () => {\r\n      fs.lstat(entry.absolute, (lstatEr, st) => {\r\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\r\n          this[SKIP](entry)\r\n          done()\r\n          return\r\n        }\r\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\r\n          return this[MAKEFS](null, entry, done)\r\n        }\r\n\r\n        if (st.isDirectory()) {\r\n          if (entry.type === 'Directory') {\r\n            const needChmod = !this.noChmod &&\r\n              entry.mode &&\r\n              (st.mode & 0o7777) !== entry.mode\r\n            const afterChmod = er => this[MAKEFS](er, entry, done)\r\n            if (!needChmod) {\r\n              return afterChmod()\r\n            }\r\n            return fs.chmod(entry.absolute, entry.mode, afterChmod)\r\n          }\r\n          // Not a dir entry, have to remove it.\r\n          // NB: the only way to end up with an entry that is the cwd\r\n          // itself, in such a way that == does not detect, is a\r\n          // tricky windows absolute path with UNC or 8.3 parts (and\r\n          // preservePaths:true, or else it will have been stripped).\r\n          // In that case, the user has opted out of path protections\r\n          // explicitly, so if they blow away the cwd, c'est la vie.\r\n          if (entry.absolute !== this.cwd) {\r\n            return fs.rmdir(entry.absolute, er =>\r\n              this[MAKEFS](er, entry, done))\r\n          }\r\n        }\r\n\r\n        // not a dir, and not reusable\r\n        // don't remove if the cwd, we want that error\r\n        if (entry.absolute === this.cwd) {\r\n          return this[MAKEFS](null, entry, done)\r\n        }\r\n\r\n        unlinkFile(entry.absolute, er =>\r\n          this[MAKEFS](er, entry, done))\r\n      })\r\n    }\r\n\r\n    if (this[CHECKED_CWD]) {\r\n      start()\r\n    } else {\r\n      checkCwd()\r\n    }\r\n  }\r\n\r\n  [MAKEFS] (er, entry, done) {\r\n    if (er) {\r\n      this[ONERROR](er, entry)\r\n      done()\r\n      return\r\n    }\r\n\r\n    switch (entry.type) {\r\n      case 'File':\r\n      case 'OldFile':\r\n      case 'ContiguousFile':\r\n        return this[FILE](entry, done)\r\n\r\n      case 'Link':\r\n        return this[HARDLINK](entry, done)\r\n\r\n      case 'SymbolicLink':\r\n        return this[SYMLINK](entry, done)\r\n\r\n      case 'Directory':\r\n      case 'GNUDumpDir':\r\n        return this[DIRECTORY](entry, done)\r\n    }\r\n  }\r\n\r\n  [LINK] (entry, linkpath, link, done) {\r\n    // XXX: get the type ('symlink' or 'junction') for windows\r\n    fs[link](linkpath, entry.absolute, er => {\r\n      if (er) {\r\n        this[ONERROR](er, entry)\r\n      } else {\r\n        this[UNPEND]()\r\n        entry.resume()\r\n      }\r\n      done()\r\n    })\r\n  }\r\n}\r\n\r\nconst callSync = fn => {\r\n  try {\r\n    return [null, fn()]\r\n  } catch (er) {\r\n    return [er, null]\r\n  }\r\n}\r\nclass UnpackSync extends Unpack {\r\n  [MAKEFS] (er, entry) {\r\n    return super[MAKEFS](er, entry, () => {})\r\n  }\r\n\r\n  [CHECKFS] (entry) {\r\n    this[PRUNECACHE](entry)\r\n\r\n    if (!this[CHECKED_CWD]) {\r\n      const er = this[MKDIR](this.cwd, this.dmode)\r\n      if (er) {\r\n        return this[ONERROR](er, entry)\r\n      }\r\n      this[CHECKED_CWD] = true\r\n    }\r\n\r\n    // don't bother to make the parent if the current entry is the cwd,\r\n    // we've already checked it.\r\n    if (entry.absolute !== this.cwd) {\r\n      const parent = normPath(path.dirname(entry.absolute))\r\n      if (parent !== this.cwd) {\r\n        const mkParent = this[MKDIR](parent, this.dmode)\r\n        if (mkParent) {\r\n          return this[ONERROR](mkParent, entry)\r\n        }\r\n      }\r\n    }\r\n\r\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))\r\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\r\n      return this[SKIP](entry)\r\n    }\r\n\r\n    if (lstatEr || this[ISREUSABLE](entry, st)) {\r\n      return this[MAKEFS](null, entry)\r\n    }\r\n\r\n    if (st.isDirectory()) {\r\n      if (entry.type === 'Directory') {\r\n        const needChmod = !this.noChmod &&\r\n          entry.mode &&\r\n          (st.mode & 0o7777) !== entry.mode\r\n        const [er] = needChmod ? callSync(() => {\r\n          fs.chmodSync(entry.absolute, entry.mode)\r\n        }) : []\r\n        return this[MAKEFS](er, entry)\r\n      }\r\n      // not a dir entry, have to remove it\r\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute))\r\n      this[MAKEFS](er, entry)\r\n    }\r\n\r\n    // not a dir, and not reusable.\r\n    // don't remove if it's the cwd, since we want that error.\r\n    const [er] = entry.absolute === this.cwd ? []\r\n      : callSync(() => unlinkFileSync(entry.absolute))\r\n    this[MAKEFS](er, entry)\r\n  }\r\n\r\n  [FILE] (entry, done) {\r\n    const mode = entry.mode & 0o7777 || this.fmode\r\n\r\n    const oner = er => {\r\n      let closeError\r\n      try {\r\n        fs.closeSync(fd)\r\n      } catch (e) {\r\n        closeError = e\r\n      }\r\n      if (er || closeError) {\r\n        this[ONERROR](er || closeError, entry)\r\n      }\r\n      done()\r\n    }\r\n\r\n    let fd\r\n    try {\r\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)\r\n    } catch (er) {\r\n      return oner(er)\r\n    }\r\n    const tx = this.transform ? this.transform(entry) || entry : entry\r\n    if (tx !== entry) {\r\n      tx.on('error', er => this[ONERROR](er, entry))\r\n      entry.pipe(tx)\r\n    }\r\n\r\n    tx.on('data', chunk => {\r\n      try {\r\n        fs.writeSync(fd, chunk, 0, chunk.length)\r\n      } catch (er) {\r\n        oner(er)\r\n      }\r\n    })\r\n\r\n    tx.on('end', _ => {\r\n      let er = null\r\n      // try both, falling futimes back to utimes\r\n      // if either fails, handle the first error\r\n      if (entry.mtime && !this.noMtime) {\r\n        const atime = entry.atime || new Date()\r\n        const mtime = entry.mtime\r\n        try {\r\n          fs.futimesSync(fd, atime, mtime)\r\n        } catch (futimeser) {\r\n          try {\r\n            fs.utimesSync(entry.absolute, atime, mtime)\r\n          } catch (utimeser) {\r\n            er = futimeser\r\n          }\r\n        }\r\n      }\r\n\r\n      if (this[DOCHOWN](entry)) {\r\n        const uid = this[UID](entry)\r\n        const gid = this[GID](entry)\r\n\r\n        try {\r\n          fs.fchownSync(fd, uid, gid)\r\n        } catch (fchowner) {\r\n          try {\r\n            fs.chownSync(entry.absolute, uid, gid)\r\n          } catch (chowner) {\r\n            er = er || fchowner\r\n          }\r\n        }\r\n      }\r\n\r\n      oner(er)\r\n    })\r\n  }\r\n\r\n  [DIRECTORY] (entry, done) {\r\n    const mode = entry.mode & 0o7777 || this.dmode\r\n    const er = this[MKDIR](entry.absolute, mode)\r\n    if (er) {\r\n      this[ONERROR](er, entry)\r\n      done()\r\n      return\r\n    }\r\n    if (entry.mtime && !this.noMtime) {\r\n      try {\r\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\r\n      } catch (er) {}\r\n    }\r\n    if (this[DOCHOWN](entry)) {\r\n      try {\r\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\r\n      } catch (er) {}\r\n    }\r\n    done()\r\n    entry.resume()\r\n  }\r\n\r\n  [MKDIR] (dir, mode) {\r\n    try {\r\n      return mkdir.sync(normPath(dir), {\r\n        uid: this.uid,\r\n        gid: this.gid,\r\n        processUid: this.processUid,\r\n        processGid: this.processGid,\r\n        umask: this.processUmask,\r\n        preserve: this.preservePaths,\r\n        unlink: this.unlink,\r\n        cache: this.dirCache,\r\n        cwd: this.cwd,\r\n        mode: mode,\r\n      })\r\n    } catch (er) {\r\n      return er\r\n    }\r\n  }\r\n\r\n  [LINK] (entry, linkpath, link, done) {\r\n    try {\r\n      fs[link + 'Sync'](linkpath, entry.absolute)\r\n      done()\r\n      entry.resume()\r\n    } catch (er) {\r\n      return this[ONERROR](er, entry)\r\n    }\r\n  }\r\n}\r\n\r\nUnpack.Sync = UnpackSync\r\nmodule.exports = Unpack\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}