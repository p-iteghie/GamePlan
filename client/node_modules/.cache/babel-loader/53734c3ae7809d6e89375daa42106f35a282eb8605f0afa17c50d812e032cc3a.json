{"ast":null,"code":"'use strict';\n\n// tar -r\nconst hlo = require('./high-level-opt.js');\nconst Pack = require('./pack.js');\nconst fs = require('fs');\nconst fsm = require('fs-minipass');\nconst t = require('./list.js');\nconst path = require('path');\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js');\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_);\n  if (!opt.file) {\n    throw new TypeError('file is required');\n  }\n  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {\n    throw new TypeError('cannot append to compressed archives');\n  }\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified');\n  }\n  files = Array.from(files);\n  return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);\n};\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt);\n  let threw = true;\n  let fd;\n  let position;\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+');\n    } catch (er) {\n      if (er.code === 'ENOENT') {\n        fd = fs.openSync(opt.file, 'w+');\n      } else {\n        throw er;\n      }\n    }\n    const st = fs.fstatSync(fd);\n    const headBuf = Buffer.alloc(512);\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n          throw new Error('cannot append to compressed archives');\n        }\n        if (!bytes) {\n          break POSITION;\n        }\n      }\n      const h = new Header(headBuf);\n      if (!h.cksumValid) {\n        break;\n      }\n      const entryBlockSize = 512 * Math.ceil(h.size / 512);\n      if (position + entryBlockSize + 512 > st.size) {\n        break;\n      }\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize;\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime);\n      }\n    }\n    threw = false;\n    streamSync(opt, p, position, fd, files);\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd);\n      } catch (er) {}\n    }\n  }\n};\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  });\n  p.pipe(stream);\n  addFilesSync(p, files);\n};\nconst replace = (opt, files, cb) => {\n  files = Array.from(files);\n  const p = new Pack(opt);\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er) {\n        fs.close(fd, _ => cb_(er));\n      } else {\n        cb_(null, pos);\n      }\n    };\n    let position = 0;\n    if (size === 0) {\n      return cb(null, 0);\n    }\n    let bufPos = 0;\n    const headBuf = Buffer.alloc(512);\n    const onread = (er, bytes) => {\n      if (er) {\n        return cb(er);\n      }\n      bufPos += bytes;\n      if (bufPos < 512 && bytes) {\n        return fs.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);\n      }\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n        return cb(new Error('cannot append to compressed archives'));\n      }\n\n      // truncated header\n      if (bufPos < 512) {\n        return cb(null, position);\n      }\n      const h = new Header(headBuf);\n      if (!h.cksumValid) {\n        return cb(null, position);\n      }\n      const entryBlockSize = 512 * Math.ceil(h.size / 512);\n      if (position + entryBlockSize + 512 > size) {\n        return cb(null, position);\n      }\n      position += entryBlockSize + 512;\n      if (position >= size) {\n        return cb(null, position);\n      }\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime);\n      }\n      bufPos = 0;\n      fs.read(fd, headBuf, 0, 512, position, onread);\n    };\n    fs.read(fd, headBuf, 0, 512, position, onread);\n  };\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject);\n    let flag = 'r+';\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+';\n        return fs.open(opt.file, flag, onopen);\n      }\n      if (er) {\n        return reject(er);\n      }\n      fs.fstat(fd, (er, st) => {\n        if (er) {\n          return fs.close(fd, () => reject(er));\n        }\n        getPos(fd, st.size, (er, position) => {\n          if (er) {\n            return reject(er);\n          }\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          });\n          p.pipe(stream);\n          stream.on('error', reject);\n          stream.on('close', resolve);\n          addFilesAsync(p, files);\n        });\n      });\n    };\n    fs.open(opt.file, flag, onopen);\n  });\n  return cb ? promise.then(cb, cb) : promise;\n};\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      });\n    } else {\n      p.add(file);\n    }\n  });\n  p.end();\n};\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift();\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files));\n    } else {\n      p.add(file);\n    }\n  }\n  p.end();\n};","map":{"version":3,"names":["hlo","require","Pack","fs","fsm","t","path","Header","module","exports","opt_","files","cb","opt","file","TypeError","gzip","brotli","endsWith","Array","isArray","length","from","sync","replaceSync","replace","p","Sync","threw","fd","position","openSync","er","code","st","fstatSync","headBuf","Buffer","alloc","POSITION","size","bufPos","bytes","readSync","Error","h","cksumValid","entryBlockSize","Math","ceil","mtimeCache","set","mtime","streamSync","closeSync","stream","WriteStreamSync","start","pipe","addFilesSync","getPos","cb_","pos","close","_","onread","read","promise","Promise","resolve","reject","on","flag","onopen","open","fstat","WriteStream","addFilesAsync","then","forEach","charAt","cwd","slice","noResume","onentry","entry","add","end","shift"],"sources":["C:/Users/Lyss/Documents/CEN3031/GamePlan/node_modules/tar/lib/replace.js"],"sourcesContent":["'use strict'\r\n\r\n// tar -r\r\nconst hlo = require('./high-level-opt.js')\r\nconst Pack = require('./pack.js')\r\nconst fs = require('fs')\r\nconst fsm = require('fs-minipass')\r\nconst t = require('./list.js')\r\nconst path = require('path')\r\n\r\n// starting at the head of the file, read a Header\r\n// If the checksum is invalid, that's our position to start writing\r\n// If it is, jump forward by the specified size (round up to 512)\r\n// and try again.\r\n// Write the new Pack stream starting there.\r\n\r\nconst Header = require('./header.js')\r\n\r\nmodule.exports = (opt_, files, cb) => {\r\n  const opt = hlo(opt_)\r\n\r\n  if (!opt.file) {\r\n    throw new TypeError('file is required')\r\n  }\r\n\r\n  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {\r\n    throw new TypeError('cannot append to compressed archives')\r\n  }\r\n\r\n  if (!files || !Array.isArray(files) || !files.length) {\r\n    throw new TypeError('no files or directories specified')\r\n  }\r\n\r\n  files = Array.from(files)\r\n\r\n  return opt.sync ? replaceSync(opt, files)\r\n    : replace(opt, files, cb)\r\n}\r\n\r\nconst replaceSync = (opt, files) => {\r\n  const p = new Pack.Sync(opt)\r\n\r\n  let threw = true\r\n  let fd\r\n  let position\r\n\r\n  try {\r\n    try {\r\n      fd = fs.openSync(opt.file, 'r+')\r\n    } catch (er) {\r\n      if (er.code === 'ENOENT') {\r\n        fd = fs.openSync(opt.file, 'w+')\r\n      } else {\r\n        throw er\r\n      }\r\n    }\r\n\r\n    const st = fs.fstatSync(fd)\r\n    const headBuf = Buffer.alloc(512)\r\n\r\n    POSITION: for (position = 0; position < st.size; position += 512) {\r\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\r\n        bytes = fs.readSync(\r\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\r\n        )\r\n\r\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\r\n          throw new Error('cannot append to compressed archives')\r\n        }\r\n\r\n        if (!bytes) {\r\n          break POSITION\r\n        }\r\n      }\r\n\r\n      const h = new Header(headBuf)\r\n      if (!h.cksumValid) {\r\n        break\r\n      }\r\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\r\n      if (position + entryBlockSize + 512 > st.size) {\r\n        break\r\n      }\r\n      // the 512 for the header we just parsed will be added as well\r\n      // also jump ahead all the blocks for the body\r\n      position += entryBlockSize\r\n      if (opt.mtimeCache) {\r\n        opt.mtimeCache.set(h.path, h.mtime)\r\n      }\r\n    }\r\n    threw = false\r\n\r\n    streamSync(opt, p, position, fd, files)\r\n  } finally {\r\n    if (threw) {\r\n      try {\r\n        fs.closeSync(fd)\r\n      } catch (er) {}\r\n    }\r\n  }\r\n}\r\n\r\nconst streamSync = (opt, p, position, fd, files) => {\r\n  const stream = new fsm.WriteStreamSync(opt.file, {\r\n    fd: fd,\r\n    start: position,\r\n  })\r\n  p.pipe(stream)\r\n  addFilesSync(p, files)\r\n}\r\n\r\nconst replace = (opt, files, cb) => {\r\n  files = Array.from(files)\r\n  const p = new Pack(opt)\r\n\r\n  const getPos = (fd, size, cb_) => {\r\n    const cb = (er, pos) => {\r\n      if (er) {\r\n        fs.close(fd, _ => cb_(er))\r\n      } else {\r\n        cb_(null, pos)\r\n      }\r\n    }\r\n\r\n    let position = 0\r\n    if (size === 0) {\r\n      return cb(null, 0)\r\n    }\r\n\r\n    let bufPos = 0\r\n    const headBuf = Buffer.alloc(512)\r\n    const onread = (er, bytes) => {\r\n      if (er) {\r\n        return cb(er)\r\n      }\r\n      bufPos += bytes\r\n      if (bufPos < 512 && bytes) {\r\n        return fs.read(\r\n          fd, headBuf, bufPos, headBuf.length - bufPos,\r\n          position + bufPos, onread\r\n        )\r\n      }\r\n\r\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\r\n        return cb(new Error('cannot append to compressed archives'))\r\n      }\r\n\r\n      // truncated header\r\n      if (bufPos < 512) {\r\n        return cb(null, position)\r\n      }\r\n\r\n      const h = new Header(headBuf)\r\n      if (!h.cksumValid) {\r\n        return cb(null, position)\r\n      }\r\n\r\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\r\n      if (position + entryBlockSize + 512 > size) {\r\n        return cb(null, position)\r\n      }\r\n\r\n      position += entryBlockSize + 512\r\n      if (position >= size) {\r\n        return cb(null, position)\r\n      }\r\n\r\n      if (opt.mtimeCache) {\r\n        opt.mtimeCache.set(h.path, h.mtime)\r\n      }\r\n      bufPos = 0\r\n      fs.read(fd, headBuf, 0, 512, position, onread)\r\n    }\r\n    fs.read(fd, headBuf, 0, 512, position, onread)\r\n  }\r\n\r\n  const promise = new Promise((resolve, reject) => {\r\n    p.on('error', reject)\r\n    let flag = 'r+'\r\n    const onopen = (er, fd) => {\r\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\r\n        flag = 'w+'\r\n        return fs.open(opt.file, flag, onopen)\r\n      }\r\n\r\n      if (er) {\r\n        return reject(er)\r\n      }\r\n\r\n      fs.fstat(fd, (er, st) => {\r\n        if (er) {\r\n          return fs.close(fd, () => reject(er))\r\n        }\r\n\r\n        getPos(fd, st.size, (er, position) => {\r\n          if (er) {\r\n            return reject(er)\r\n          }\r\n          const stream = new fsm.WriteStream(opt.file, {\r\n            fd: fd,\r\n            start: position,\r\n          })\r\n          p.pipe(stream)\r\n          stream.on('error', reject)\r\n          stream.on('close', resolve)\r\n          addFilesAsync(p, files)\r\n        })\r\n      })\r\n    }\r\n    fs.open(opt.file, flag, onopen)\r\n  })\r\n\r\n  return cb ? promise.then(cb, cb) : promise\r\n}\r\n\r\nconst addFilesSync = (p, files) => {\r\n  files.forEach(file => {\r\n    if (file.charAt(0) === '@') {\r\n      t({\r\n        file: path.resolve(p.cwd, file.slice(1)),\r\n        sync: true,\r\n        noResume: true,\r\n        onentry: entry => p.add(entry),\r\n      })\r\n    } else {\r\n      p.add(file)\r\n    }\r\n  })\r\n  p.end()\r\n}\r\n\r\nconst addFilesAsync = (p, files) => {\r\n  while (files.length) {\r\n    const file = files.shift()\r\n    if (file.charAt(0) === '@') {\r\n      return t({\r\n        file: path.resolve(p.cwd, file.slice(1)),\r\n        noResume: true,\r\n        onentry: entry => p.add(entry),\r\n      }).then(_ => addFilesAsync(p, files))\r\n    } else {\r\n      p.add(file)\r\n    }\r\n  }\r\n  p.end()\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}