{"ast":null,"code":"'use strict';\n\nvar Promise = global.Promise;\n\n/// encapsulate a method with a node-style callback in a Promise\n/// @param {object} 'this' of the encapsulated function\n/// @param {function} function to be encapsulated\n/// @param {Array-like} args to be passed to the called function\n/// @return {Promise} a Promise encapsulating the function\nmodule.exports.promise = function (fn, context, args) {\n  if (!Array.isArray(args)) {\n    args = Array.prototype.slice.call(args);\n  }\n  if (typeof fn !== 'function') {\n    return Promise.reject(new Error('fn must be a function'));\n  }\n  return new Promise(function (resolve, reject) {\n    args.push(function (err, data) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n    fn.apply(context, args);\n  });\n};\n\n/// @param {err} the error to be thrown\nmodule.exports.reject = function (err) {\n  return Promise.reject(err);\n};\n\n/// changes the promise implementation that bcrypt uses\n/// @param {Promise} the implementation to use\nmodule.exports.use = function (promise) {\n  Promise = promise;\n};","map":{"version":3,"names":["Promise","global","module","exports","promise","fn","context","args","Array","isArray","prototype","slice","call","reject","Error","resolve","push","err","data","apply","use"],"sources":["C:/Users/Lyss/Documents/CEN3031/GamePlan/node_modules/bcrypt/promises.js"],"sourcesContent":["'use strict';\r\n\r\nvar Promise = global.Promise;\r\n\r\n/// encapsulate a method with a node-style callback in a Promise\r\n/// @param {object} 'this' of the encapsulated function\r\n/// @param {function} function to be encapsulated\r\n/// @param {Array-like} args to be passed to the called function\r\n/// @return {Promise} a Promise encapsulating the function\r\nmodule.exports.promise = function (fn, context, args) {\r\n\r\n    if (!Array.isArray(args)) {\r\n        args = Array.prototype.slice.call(args);\r\n    }\r\n\r\n    if (typeof fn !== 'function') {\r\n        return Promise.reject(new Error('fn must be a function'));\r\n    }\r\n\r\n    return new Promise(function(resolve, reject) {\r\n        args.push(function(err, data) {\r\n            if (err) {\r\n                reject(err);\r\n            } else {\r\n                resolve(data);\r\n            }\r\n        });\r\n\r\n        fn.apply(context, args);\r\n    });\r\n};\r\n\r\n/// @param {err} the error to be thrown\r\nmodule.exports.reject = function (err) {\r\n    return Promise.reject(err);\r\n};\r\n\r\n/// changes the promise implementation that bcrypt uses\r\n/// @param {Promise} the implementation to use\r\nmodule.exports.use = function(promise) {\r\n  Promise = promise;\r\n};\r\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,OAAO,GAAGC,MAAM,CAACD,OAAO;;AAE5B;AACA;AACA;AACA;AACA;AACAE,MAAM,CAACC,OAAO,CAACC,OAAO,GAAG,UAAUC,EAAE,EAAEC,OAAO,EAAEC,IAAI,EAAE;EAElD,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,IAAI,CAAC,EAAE;IACtBA,IAAI,GAAGC,KAAK,CAACE,SAAS,CAACC,KAAK,CAACC,IAAI,CAACL,IAAI,CAAC;EAC3C;EAEA,IAAI,OAAOF,EAAE,KAAK,UAAU,EAAE;IAC1B,OAAOL,OAAO,CAACa,MAAM,CAAC,IAAIC,KAAK,CAAC,uBAAuB,CAAC,CAAC;EAC7D;EAEA,OAAO,IAAId,OAAO,CAAC,UAASe,OAAO,EAAEF,MAAM,EAAE;IACzCN,IAAI,CAACS,IAAI,CAAC,UAASC,GAAG,EAAEC,IAAI,EAAE;MAC1B,IAAID,GAAG,EAAE;QACLJ,MAAM,CAACI,GAAG,CAAC;MACf,CAAC,MAAM;QACHF,OAAO,CAACG,IAAI,CAAC;MACjB;IACJ,CAAC,CAAC;IAEFb,EAAE,CAACc,KAAK,CAACb,OAAO,EAAEC,IAAI,CAAC;EAC3B,CAAC,CAAC;AACN,CAAC;;AAED;AACAL,MAAM,CAACC,OAAO,CAACU,MAAM,GAAG,UAAUI,GAAG,EAAE;EACnC,OAAOjB,OAAO,CAACa,MAAM,CAACI,GAAG,CAAC;AAC9B,CAAC;;AAED;AACA;AACAf,MAAM,CAACC,OAAO,CAACiB,GAAG,GAAG,UAAShB,OAAO,EAAE;EACrCJ,OAAO,GAAGI,OAAO;AACnB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}